<html lang="ja">

<head>
    <title>ドット絵エディター</title>
    <meta charset="UTF-8">
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        body {
            background-color: darkslategrey;
        }

        input[type="number"] {
            width: 64px;
            text-align: right;
        }

        div.layout {
            display: grid;
            grid-auto-columns: max-content;
            grid-auto-rows: max-content;
            grid-template-areas:
                "a b b b"
                "c e e g"
                "d e e g"
                "d e e g";
        }

        div.hbox {
            clear: both;
        }

        div.vbox {
            float: left;
        }

        div.rightvbox {
            float: right;
        }

        div.canvasframe {
            overflow: scroll;
            resize: both;
            clear: both;
        }

        div.overflow_frame {
            padding: 24px;
            width: max-content;
            height: max-content;
        }

        div#settingsblock {
            grid-area: a;
            background-color: darkgrey;
        }

        div#toolsblock {
            grid-area: b;
            background-color: skyblue;
        }

        div#paletteblock {
            grid-area: c;
            background-color: darkseagreen;
        }

        div#viewblock {
            grid-area: d;
        }

        div#viewframe {
            width: 200px;
            height: 200px;
        }

        div#editblock {
            grid-area: e;
            background-color: mediumpurple;
        }

        div#editframe {
            width: 128px;
            height: 384px;
        }

        div#layerblock {
            grid-area: g;
            background-color: yellowgreen;
        }

        div#manualblock {
            background-color: darkslategrey;
        }
    </style>
</head>

<body>
    <div class="layout">
        <div id="viewblock"></div>
        <div id="layerblock"></div>
        <div class="vbox" id="settingsblock">
            <div class="hbox">
                <input type="checkbox" id="view_grid" checked>
                <label for="view_grid">小グリッド</label>
                <input type="checkbox" id="view_index">
                <label for="view_index">色番号表示</label>
            </div>
            <div class="hbox">
                <input type="checkbox" id="view_large_grid" checked>
                <label for="view_large_grid">大グリッド</label>
                <input type="number" id="large_grid_width" min="2" max="512" value="16">
                <input type="number" id="large_grid_height" min="2" max="512" value="16">
            </div>
            <div class="hbox">
                <label for="grid_color">グリッド／番号色</label>
                <input type="color" id="grid_color" value="#333333">
            </div>
        </div>
        <div id="toolsblock">
            <div class="vbox">
                <div class="hbox">
                    <input type="radio" name="tools" id="pen_tool" value="pen_tool" checked>
                    <label for="pen_tool">ペン</label>
                </div>
                <div class="hbox">
                    <input type="radio" name="tools" id="paint_tool" value="paint_tool">
                    <label for="paint_tool">塗りつぶし</label>
                </div>
                <div class="hbox">
                    <input type="radio" name="tools" id="rectangle_select_tool" value="rectangle_select_tool">
                    <label for="rectangle_select_tool">矩形選択</label>
                    <button id="rectangle_fill_button">矩形塗り潰し</button>
                    <button id="v_turn_button">上下反転</button>
                    <button id="h_turn_button">左右反転</button>
                    <button id="break_to_mask_button">マスク化</button>
                    <button id="release_targetting_button">選択解除</button>
                </div>
            </div>
            <div class="vbox">
                <div class="hbox">
                    <button id="undo_button">Undo</button>
                    <button id="redo_button">Redo</button>
                </div>
                <div class="hbox">
                    <button id="turn_mask_button">マスク反転</button>
                    <button id="delete_mask_button">マスク消去</button>
                </div>
            </div>
        </div>

        <div id="paletteblock">
            <div class="hbox" id="colorpalette">
            </div>
            <div class="hbox">
                <button id="delete_all_unused_colors_button">未使用色を全削除</button>
            </div>
        </div>
        <div id="editblock">
            <div class="hbox">
                読み込み<input type="file" id="edit_filepath">
            </div>
            <div class="hbox" id="edit_command">
                保存形式
                <select id="edit_save_format">
                    <option value="JSON" selected>JSON</option>
                    <option value="WindowsIndexColorBitmap">BMP</option>
                </select>
                <input type="text" id="edit_data_name" value="new_picture">
            </div>
            <div class="hbox">
                <div class="vbox">
                    横x縦<input id="editwidth" type="number" min="1">x
                    <input id="editheight" type="number" min="1">
                </div>
                <div class="rightvbox">
                    表示倍率
                    <select id="edit_scale">
                        <option value="1">x1</option>
                        <option value="2">x2</option>
                        <option value="4" selected>x4</option>
                        <option value="8">x8</option>
                        <option value="16">x16</option>
                        <option value="24">x24</option>
                        <option value="32">x32</option>
                    </select>
                </div>
            </div>
            <div class="canvasframe" id="editframe">
                <div class="overflow_frame">
                    <canvas id="edit" width="256" height="192" onContextmenu="return false;"></canvas>
                </div>
            </div>
        </div>
    </div>
    <div id="manualblock">
        <details>
            <summary>操作方法など</summary>
            <h3>ショートカット</h3>
            <ul>
                <li>Ctrl+s:ローカルストレージに上書き保存</li>
                <li>Ctrl+d:選択範囲解除</li>
                <li>Ctrl+c:選択範囲をコピー</li>
                <li>Ctrl+v:コピー内容をペースト</li>
                <li>Ctrl+z:元に戻す(Undo)</li>
                <li>Ctrl+y:やり直す(Redo)</li>
            </ul>
            <h3>ツール類</h3>
            <h4>ペン</h4>
            <ul>
                <li>右ボタンクリック：スポイト機能</li>
            </ul>
            <h4>塗り潰し</h4>
            <ul>
                <li>右ボタンクリック：スポイト機能</li>
            </ul>
            <h3>アニメーションプレビュー</h3>
            <p>システムはユーザーに指定されたスプライトサイズでキャンバスを分割し、ラスタ方向へスプライトインデックスを自動で割り付ける。</p>
            <p>テキストエリアにカンマ(,)区切りでスプライトインデックス（0〜）を指定する事で、指定した順にスプライトアニメーション表示する。</p>
            <p>毎秒約60フレーム描画しており、1コマに何フレームかけるか設定する事で、アニメーション速度を調整できる。</p>
        </details>
    </div>
<script>/******/ (() => { // webpackBootstrap
/*!***********************!*\
  !*** ./built/main.js ***!
  \***********************/
var Browser;
(function (Browser) {
    function isStorageAvailable(type) {
        let storage;
        try {
            storage = window[type];
            const x = '__storage_test__';
            storage.setItem(x, x);
            storage.removeItem(x);
            return true;
        }
        catch (e) {
            return (e instanceof DOMException) && (
            // everything except Firefox
            e.code === 22 ||
                // Firefox
                e.code === 1014 ||
                // test name field too, because code might not be present
                // everything except Firefox
                e.name === 'QuotaExceededError' ||
                // Firefox
                e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&
                // acknowledge QuotaExceededError only if there's something already stored
                (storage && storage.length !== 0);
        }
    }
    Browser.isStorageAvailable = isStorageAvailable;
})(Browser || (Browser = {}));
var CanvasTools;
(function (CanvasTools_1) {
    class Tool {
        LeftButtonDown(pixel_w, pixel_h) { }
        ;
        LeftButtonUp(pixel_w, pixel_h) { }
        ;
        RightButtonDown(pixel_w, pixel_h) { }
        ;
        RightButtonUp(pixel_w, pixel_h) { }
        ;
        MouseMove(pixel_w, pixel_h) { }
        ;
        MouseOut(pixel_w, pixel_h) { }
        ;
    }
    CanvasTools_1.Tool = Tool;
    class CallbackTable {
        constructor(is_pixel_writable_cb_, write_pixel_cb_, get_pixel_cb_, get_canvas_size_cb_, get_view_scale_cb_, color_picker_cb_, select_area_update_cb_, begin_cb_, prechange_cb_, postchange_cb_, end_cb_) {
            this.is_pixel_writable_cb_ = is_pixel_writable_cb_;
            this.write_pixel_cb_ = write_pixel_cb_;
            this.get_pixel_cb_ = get_pixel_cb_;
            this.get_canvas_size_cb_ = get_canvas_size_cb_;
            this.get_view_scale_cb_ = get_view_scale_cb_;
            this.color_picker_cb_ = color_picker_cb_;
            this.select_area_update_cb_ = select_area_update_cb_;
            this.begin_cb_ = begin_cb_;
            this.prechange_cb_ = prechange_cb_;
            this.postchange_cb_ = postchange_cb_;
            this.end_cb_ = end_cb_;
        }
    }
    CanvasTools_1.CallbackTable = CallbackTable;
    class PenTool extends Tool {
        constructor(cb_table) {
            super();
            this.is_activated = false;
            this.cb_table_ = cb_table;
        }
        LeftButtonDown(pixel_w, pixel_h) {
            this.cb_table_.begin_cb_();
            this.cb_table_.prechange_cb_();
            this.cb_table_.write_pixel_cb_(pixel_w, pixel_h);
            this.last_point_w = pixel_w;
            this.last_point_h = pixel_h;
            this.is_activated = true;
            return;
        }
        ;
        LeftButtonUp(pixel_w, pixel_h) {
            this.is_activated = false;
            this.cb_table_.postchange_cb_();
            this.cb_table_.end_cb_();
        }
        RightButtonDown(pixel_w, pixel_h) {
            this.cb_table_.color_picker_cb_(pixel_w, pixel_h);
            return;
        }
        ;
        MouseMove(pixel_w, pixel_h) {
            if (this.is_activated) {
                Misc.LineTo2d(this.last_point_w, this.last_point_h, pixel_w, pixel_h, this.cb_table_.write_pixel_cb_);
            }
            else {
                this.cb_table_.begin_cb_();
                this.cb_table_.prechange_cb_();
            }
            this.last_point_w = pixel_w;
            this.last_point_h = pixel_h;
            this.is_activated = true;
            return;
        }
        ;
        MouseOut(pixel_w, pixel_h) {
            if (this.is_activated) {
                Misc.LineTo2d(this.last_point_w, this.last_point_h, pixel_w, pixel_h, this.cb_table_.write_pixel_cb_);
            }
            this.is_activated = false;
        }
        ;
    }
    CanvasTools_1.PenTool = PenTool;
    class PaintTool extends Tool {
        constructor(cb_table) {
            super();
            this.cb_table_ = cb_table;
        }
        ExtractRegionPixelSet(start_point, max_w, max_h) {
            const min_w = 0;
            const min_h = 0;
            const region_pixels = new Set();
            const next_pixel_queue = new Array();
            const target_color_index = this.cb_table_.get_pixel_cb_(start_point.w, start_point.h);
            region_pixels.add(start_point.ToIndex(max_w));
            next_pixel_queue.push(start_point);
            const AddPixelToRegion = (new_point) => {
                if (this.cb_table_.get_pixel_cb_(new_point.w, new_point.h) !== target_color_index) {
                    return;
                }
                if (region_pixels.has(new_point.ToIndex(max_w))) {
                    return;
                }
                next_pixel_queue.push(new_point);
                region_pixels.add(new_point.ToIndex(max_w));
                return;
            };
            for (;;) {
                if (next_pixel_queue.length === 0) {
                    break;
                }
                let pixel = next_pixel_queue.shift();
                if (min_h < pixel.h) {
                    if (this.cb_table_.is_pixel_writable_cb_(pixel.w + 0, pixel.h - 1)) {
                        AddPixelToRegion(new PixelPoint(pixel.w + 0, pixel.h - 1));
                    }
                }
                if (min_w < pixel.w) {
                    if (this.cb_table_.is_pixel_writable_cb_(pixel.w - 1, pixel.h + 0)) {
                        AddPixelToRegion(new PixelPoint(pixel.w - 1, pixel.h + 0));
                    }
                }
                if (pixel.w < max_w - 1) {
                    if (this.cb_table_.is_pixel_writable_cb_(pixel.w + 1, pixel.h + 0)) {
                        AddPixelToRegion(new PixelPoint(pixel.w + 1, pixel.h + 0));
                    }
                }
                if (pixel.h < max_h - 1) {
                    if (this.cb_table_.is_pixel_writable_cb_(pixel.w + 0, pixel.h + 1)) {
                        AddPixelToRegion(new PixelPoint(pixel.w + 0, pixel.h + 1));
                    }
                }
            }
            return region_pixels;
        }
        ;
        LeftButtonDown(pixel_w, pixel_h) {
            this.cb_table_.begin_cb_();
            this.cb_table_.prechange_cb_();
            const selected_pixel = new PixelPoint(pixel_w, pixel_h);
            const [max_w, max_h] = this.cb_table_.get_canvas_size_cb_();
            const region_pixel_set = this.ExtractRegionPixelSet(selected_pixel, max_w, max_h);
            region_pixel_set.forEach((pixel_index) => {
                const w = PixelPoint.IndexToPixelPointW(pixel_index, max_w);
                const h = PixelPoint.IndexToPixelPointH(pixel_index, max_w);
                this.cb_table_.write_pixel_cb_(w, h);
            });
            this.cb_table_.postchange_cb_();
            this.cb_table_.end_cb_();
        }
        ;
        RightButtonDown(x, y) {
            this.cb_table_.color_picker_cb_(x, y);
        }
        ;
    }
    CanvasTools_1.PaintTool = PaintTool;
    class RectangleSelectTool extends Tool {
        constructor(cb_table) {
            super();
            this.start_x = 0;
            this.start_y = 0;
            this.cb_table_ = cb_table;
        }
        LeftButtonDown(start_x, start_y) {
            this.start_x = start_x;
            this.start_y = start_y;
            this.cb_table_.select_area_update_cb_(this.start_x, this.start_y, this.start_x, this.start_y);
        }
        ;
        MouseMove(end_x, end_y) {
            this.cb_table_.select_area_update_cb_(this.start_x, this.start_y, end_x, end_y);
            return;
        }
        ;
    }
    CanvasTools_1.RectangleSelectTool = RectangleSelectTool;
    class CanvasTools {
        constructor(is_pixel_writable_cb_, write_pixel_cb_, get_pixel_cb_, get_canvas_size_cb_, get_view_scale_cb_, color_picker_cb_, select_area_update_cb_, begin_cb_, prechange_cb_, postchange_cb_, end_cb_) {
            this.cb_table_ = new CallbackTable(is_pixel_writable_cb_, write_pixel_cb_, get_pixel_cb_, get_canvas_size_cb_, get_view_scale_cb_, color_picker_cb_, select_area_update_cb_, begin_cb_, prechange_cb_, postchange_cb_, end_cb_);
            this.pen_tool_ = new PenTool(this.cb_table_);
            this.paint_tool_ = new PaintTool(this.cb_table_);
            this.rectangle_select_tool_ = new RectangleSelectTool(this.cb_table_);
            this.current_tool_ = this.pen_tool_;
        }
        static GetPixelPoint(event, block_size) {
            const rect = event.target.getBoundingClientRect();
            const w = Math.floor((event.clientX - rect.left) / block_size);
            const h = Math.floor((event.clientY - rect.top) / block_size);
            return [w, h];
        }
        ;
        static GetTouchPixelPoint(event, block_size) {
            const rect = event.target.getBoundingClientRect();
            const w = Math.floor((event.touches[0].clientX - rect.left) / block_size);
            const h = Math.floor((event.touches[0].clientY - rect.top) / block_size);
            return [w, h];
        }
        ;
        MouseDownCallback(event) {
            if (event.button === 0) {
                this.current_tool_.LeftButtonDown(...CanvasTools.GetPixelPoint(event, this.cb_table_.get_view_scale_cb_()));
            }
            else if (event.button === 2) {
                this.current_tool_.RightButtonDown(...CanvasTools.GetPixelPoint(event, this.cb_table_.get_view_scale_cb_()));
            }
        }
        ;
        MouseUpCallback(event) {
            if (event.button === 0) {
                this.current_tool_.LeftButtonUp(...CanvasTools.GetPixelPoint(event, this.cb_table_.get_view_scale_cb_()));
            }
            else if (event.button === 2) {
                this.current_tool_.RightButtonUp(...CanvasTools.GetPixelPoint(event, this.cb_table_.get_view_scale_cb_()));
            }
        }
        ;
        MouseMoveCallback(event) {
            if (event.buttons === 0x01) {
                this.current_tool_.MouseMove(...CanvasTools.GetPixelPoint(event, this.cb_table_.get_view_scale_cb_()));
            }
        }
        ;
        MouseOutCallback(event) {
            if (event.buttons === 0x01) {
                this.current_tool_.MouseOut(...CanvasTools.GetPixelPoint(event, this.cb_table_.get_view_scale_cb_()));
            }
        }
        ;
        TouchStartCallback(event) {
            if (event.touches.length === 1) {
                this.current_tool_.LeftButtonDown(...CanvasTools.GetTouchPixelPoint(event, this.cb_table_.get_view_scale_cb_()));
            }
        }
        ;
        TouchEndCallback(event) {
            if (event.touches.length === 1) {
                this.current_tool_.LeftButtonUp(...CanvasTools.GetTouchPixelPoint(event, this.cb_table_.get_view_scale_cb_()));
            }
        }
        ;
        TouchMoveCallback(event) {
            if (event.touches.length === 1) {
                this.current_tool_.MouseMove(...CanvasTools.GetTouchPixelPoint(event, this.cb_table_.get_view_scale_cb_()));
            }
            event.preventDefault();
        }
        ;
        Attach(canvas) {
            canvas.addEventListener('mousedown', (event) => { this.MouseDownCallback(event); });
            canvas.addEventListener('mouseup', (event) => { this.MouseUpCallback(event); });
            canvas.addEventListener('contextmenu', (event) => { this.MouseDownCallback(event); });
            canvas.addEventListener('mousemove', (event) => { this.MouseMoveCallback(event); });
            canvas.addEventListener('mouseout', (event) => { this.MouseOutCallback(event); });
            canvas.addEventListener('touchstart', (event) => { this.TouchStartCallback(event); });
            canvas.addEventListener('touchend', (event) => { this.TouchEndCallback(event); });
            canvas.addEventListener('touchmove', (event) => { this.TouchMoveCallback(event); });
        }
        set tool_kind(kind) {
            switch (kind) {
                case "pen":
                    this.current_tool_ = this.pen_tool_;
                    break;
                case "paint":
                    this.current_tool_ = this.paint_tool_;
                    break;
                case "rectangle_select":
                    this.current_tool_ = this.rectangle_select_tool_;
                    break;
            }
        }
    }
    CanvasTools_1.CanvasTools = CanvasTools;
})(CanvasTools || (CanvasTools = {}));
var WindowsIndexColorBitmap;
(function (WindowsIndexColorBitmap) {
    const bmp_file_header_size = 14;
    const bmp_info_header_size = 40;
    const palette_size = 4 * 256;
    const pixels_offset = bmp_file_header_size + bmp_info_header_size + palette_size;
    const Store16LE = function (bytes, offset, value) {
        bytes[offset + 0] = value & 0x00ff;
        bytes[offset + 1] = (value >> 8) & 0x00ff;
    };
    const Store32LE = function (bytes, offset, value) {
        bytes[offset + 0] = value & 0x000000ff;
        bytes[offset + 1] = (value >> 8) & 0x000000ff;
        bytes[offset + 2] = (value >> 16) & 0x000000ff;
        bytes[offset + 3] = (value >> 24) & 0x000000ff;
    };
    const Load16LE = function (bytes, offset) {
        return (bytes[offset + 0] & 0x00ff) | ((bytes[offset + 1] << 8) & 0xff00);
    };
    const Load32LE = function (bytes, offset) {
        return (bytes[offset + 0] & 0x000000ff)
            | ((bytes[offset + 1] << 8) & 0x0000ff00)
            | ((bytes[offset + 2] << 16) & 0x00ff0000)
            | ((bytes[offset + 3] << 14) & 0xff000000);
    };
    const RgbStringToRgbValues = function (rgb_string) {
        const [r_string, g_string, b_string] = rgb_string.split('(')[1].split(')')[0].split(',');
        return [Number(r_string), Number(g_string), Number(b_string)];
    };
    function Serialize(color_palette, pixels, width, height) {
        const bmp_width = Math.ceil(width / 4) * 4;
        const pixels_size = bmp_width * height;
        const binary_size = bmp_file_header_size + bmp_info_header_size + palette_size + pixels_size;
        const buffer = new ArrayBuffer(binary_size);
        const bytes = new Uint8Array(buffer);
        bytes[0] = 0x42;
        bytes[1] = 0x4d;
        /* Bitmap File Header */
        Store32LE(bytes, 2, binary_size);
        Store16LE(bytes, 6, 0);
        Store16LE(bytes, 8, 0);
        Store32LE(bytes, 10, pixels_offset);
        /* Bitmap Info Header */
        Store32LE(bytes, 14, 40);
        Store32LE(bytes, 18, width);
        Store32LE(bytes, 22, height);
        Store16LE(bytes, 26, 1);
        Store16LE(bytes, 28, 8);
        Store32LE(bytes, 30, 0);
        Store32LE(bytes, 34, pixels_size);
        Store32LE(bytes, 38, 0);
        Store32LE(bytes, 42, 0);
        Store32LE(bytes, 46, 256);
        Store32LE(bytes, 50, 256);
        /* Color palette */
        for (let i = 0; i < 256; i++) {
            const [r, g, b] = RgbStringToRgbValues(color_palette[i]);
            bytes[54 + 4 * i + 0] = b;
            bytes[54 + 4 * i + 1] = g;
            bytes[54 + 4 * i + 2] = r;
            bytes[54 + 4 * i + 3] = 0;
        }
        /* pixels */
        /* ラスタ座標系から数学座標系に入れ替えて出力する */
        for (let h = 0; h < height; h++) {
            for (let w = 0; w < width; w++) {
                let offset = pixels_offset + bmp_width * (height - h - 1) + w;
                bytes[offset] = pixels[h][w];
            }
        }
        return bytes;
    }
    WindowsIndexColorBitmap.Serialize = Serialize;
    function Deserialize(buffer) {
        const bytes = new Uint8Array(buffer);
        console.log(bytes[0]);
        console.log(bytes[1]);
        if (bytes[0] !== 0x42) {
            return null;
        }
        if (bytes[1] !== 0x4d) {
            return null;
        }
        if (Load32LE(bytes, 10) !== pixels_offset) {
            return null;
        }
        if (Load16LE(bytes, 26) !== 1) {
            return null;
        }
        if (Load16LE(bytes, 28) !== 8) {
            return null;
        }
        const width = Load32LE(bytes, 18);
        const height = Load32LE(bytes, 22);
        const bmp_width = Math.ceil(width / 4) * 4;
        const color_palette = new Array(256);
        for (let i = 0; i < 256; i++) {
            const b = bytes[54 + 4 * i + 0];
            const g = bytes[54 + 4 * i + 1];
            const r = bytes[54 + 4 * i + 2];
            color_palette[i] = `rgb(${r},${g},${b})`;
        }
        /* pixels */
        /* 数学座標系からラスタ座標系に入れ替えて読みこむ */
        const pixels = Misc.Make2dArray(width, height, 0);
        for (let h = 0; h < height; h++) {
            for (let w = 0; w < width; w++) {
                let offset = pixels_offset + bmp_width * (height - h - 1) + w;
                pixels[h][w] = bytes[offset];
            }
        }
        return [color_palette, pixels, width, height];
    }
    WindowsIndexColorBitmap.Deserialize = Deserialize;
})(WindowsIndexColorBitmap || (WindowsIndexColorBitmap = {}));
var Misc;
(function (Misc) {
    function Make2dArray(width, height, initial_value) {
        return JSON.parse(JSON.stringify((new Array(height)).fill((new Array(width)).fill(initial_value))));
    }
    Misc.Make2dArray = Make2dArray;
    function LineTo2d(x0, y0, x1, y1, PixelOnLineCallback) {
        const dx = (x0 < x1) ? x1 - x0 : x0 - x1;
        const dy = (y0 < y1) ? y1 - y0 : y0 - y1;
        const sx = (x0 < x1) ? 1 : -1;
        const sy = (y0 < y1) ? 1 : -1;
        let e1 = dx - dy;
        for (;;) {
            PixelOnLineCallback(x0, y0);
            if ((x0 === x1) && (y0 === y1)) {
                break;
            }
            const e2 = e1 * 2;
            if (-dy < e2) {
                e1 -= dy;
                x0 += sx;
            }
            if (e2 < dx) {
                e1 += dx;
                y0 += sy;
            }
        }
    }
    Misc.LineTo2d = LineTo2d;
    ;
    function RgbToHexColor(r, g, b) {
        const r_hex = ('00' + r.toString(16)).slice(-2);
        const g_hex = ('00' + g.toString(16)).slice(-2);
        const b_hex = ('00' + b.toString(16)).slice(-2);
        return `#${r_hex}${g_hex}${b_hex}`;
    }
    Misc.RgbToHexColor = RgbToHexColor;
    function RgbStringToHexColor(rgb_string) {
        const [r_string, g_string, b_string] = rgb_string.split('(')[1].split(')')[0].split(',');
        const r_hex = ('00' + Number(r_string).toString(16)).slice(-2);
        const g_hex = ('00' + Number(g_string).toString(16)).slice(-2);
        const b_hex = ('00' + Number(b_string).toString(16)).slice(-2);
        return `#${r_hex}${g_hex}${b_hex}`;
    }
    Misc.RgbStringToHexColor = RgbStringToHexColor;
    function ExtractBaseName(filepath) {
        const path_delimiter = /\\/g;
        const path_tokens = filepath.slice(0).replace(path_delimiter, '/').split('/');
        const filename = (2 <= path_tokens.length) ? path_tokens[path_tokens.length - 1] : path_tokens[0];
        const name_tokens = filename.split('.');
        const basename = (2 <= name_tokens.length) ? name_tokens.splice(0, name_tokens.length - 1).join('.') : name_tokens[0];
        return basename;
    }
    Misc.ExtractBaseName = ExtractBaseName;
    function MakeWebSafeColorList() {
        const gray_colors = Array(0); /* 利便性のためにグレースケールだけ別で並べる */
        const other_colors = Array(0);
        const blank_colors = Array(256 - (6 * 6 * 6)).fill('#000000');
        const c = ['00', '33', '66', '99', 'cc', 'ff'];
        let i = 0;
        for (let b = 0; b < 6; b++) {
            for (let g = 0; g < 6; g++) {
                for (let r = 0; r < 6; r++) {
                    const color = `#${c[r]}${c[g]}${c[b]}`;
                    if (r === g && r === b) {
                        gray_colors.push(color);
                    }
                    else {
                        other_colors.push(color);
                    }
                }
            }
        }
        return gray_colors.concat(other_colors).concat(blank_colors);
    }
    Misc.MakeWebSafeColorList = MakeWebSafeColorList;
    function HsvToRgb(H, S, V) {
        /* 0 <= h < 360 */
        const F = V * (1 - S); /* floor */
        const C = V; /* ceil */
        const area_index = Number(Math.floor(H / 60));
        const coef = (area_index % 2) === 0 ? (H % 60) / 60 : 1 - (H % 60) / 60;
        const X = coef * (C - F) + F;
        let r = 0;
        let g = 0;
        let b = 0;
        switch (area_index) {
            case 0:
                [r, g, b] = [C, X, F];
                break;
            case 1:
                [r, g, b] = [X, C, F];
                break;
            case 2:
                [r, g, b] = [F, C, X];
                break;
            case 3:
                [r, g, b] = [F, X, C];
                break;
            case 4:
                [r, g, b] = [X, F, C];
                break;
            case 5:
                [r, g, b] = [C, F, X];
                break;
        }
        return [Math.floor(r * 255), Math.floor(g * 255), Math.floor(b * 255)];
    }
    Misc.HsvToRgb = HsvToRgb;
    function MakeHSVBalancedColorList(s_divide) {
        const colors = new Array(256);
        const num_colors = 16;
        let i = 0;
        /* gray scale */
        const grayscale_max_v = Math.floor(256 / num_colors);
        for (let v = 0; v < grayscale_max_v; v++) {
            let [r, g, b] = HsvToRgb(0, 0, v / (grayscale_max_v - 1));
            colors[i] = this.RgbToHexColor(r, g, b);
            i++;
        }
        const h_step = Math.floor(360 / (num_colors - 1));
        const num_s = s_divide;
        const num_v = Math.floor(256 / (s_divide * num_colors));
        const max_s = num_s + 1;
        const max_v = num_v + 1;
        for (let h = 0; h < 360; h += h_step) {
            for (let s = 1; s < max_s; s++) {
                for (let v = 1; v < max_v; v++) {
                    let [r, g, b] = HsvToRgb(h, s / num_s, v / num_v);
                    colors[i] = this.RgbToHexColor(r, g, b);
                    i++;
                }
            }
        }
        return colors;
    }
    Misc.MakeHSVBalancedColorList = MakeHSVBalancedColorList;
})(Misc || (Misc = {}));
var UiParts;
(function (UiParts) {
    class LayerUi {
        constructor(parent, order, name, color, user_value) {
            this.parent_ = parent;
            this.user_value_ = user_value;
            this.layer_frame_ = document.createElement("div");
            this.layer_frame_.style.display = "flex";
            this.layer_frame_.style.alignItems = "center";
            this.tab_ = document.createElement("div");
            this.tab_.style.width = (40).toString();
            this.tab_.style.height = (32).toString();
            this.tab_.style.backgroundColor = color;
            this.tab_.style.display = "flex";
            this.tab_.style.justifyContent = "center";
            this.tab_.style.alignItems = "center";
            this.thumbnail_ = document.createElement("canvas");
            this.layer_lock_checkbox_ = document.createElement("input");
            this.layer_view_checkbox_ = document.createElement("input");
            this.layer_name_ = document.createElement("input");
            this.thumbnail_.width = 16;
            this.thumbnail_.height = 16;
            this.layer_lock_checkbox_.type = "checkbox";
            this.layer_lock_checkbox_.checked = false;
            this.layer_view_checkbox_.type = "checkbox";
            this.layer_view_checkbox_.checked = true;
            this.layer_name_.type = "text";
            this.layer_name_.value = name;
            this.layer_name_.style.height = '1em';
            this.layer_name_.style.paddingTop = (8).toString();
            this.layer_name_.style.paddingBottom = (8).toString();
            this.tab_.appendChild(this.thumbnail_);
            this.layer_frame_.appendChild(this.tab_);
            this.layer_frame_.appendChild(this.layer_lock_checkbox_);
            this.layer_frame_.appendChild(this.layer_view_checkbox_);
            this.layer_frame_.appendChild(this.layer_name_);
            this.order_ = order;
            this.layer_frame_.style.order = this.order_.toString();
            this.layer_frame_.tabIndex = 0;
            this.layer_frame_.style.backgroundColor = "rgb(255,255,255)";
            this.parent_.appendChild(this.layer_frame_);
        }
        Destruct() {
            this.parent_.removeChild(this.layer_frame_);
            return this.user_value_;
        }
        FocusIn() {
            this.layer_frame_.style.backgroundColor = 'rgb(0, 0, 255)';
            this.layer_frame_.style.boxShadow = "0px 0px 0px 0px";
            this.tab_.style.boxShadow = this.layer_frame_.style.boxShadow;
            this.Update(this.update_state_callback_, true, false);
        }
        FocusOut() {
            this.layer_frame_.style.backgroundColor = 'rgb(255, 255, 255)';
            this.layer_frame_.style.boxShadow = "0px 8px 16px -2px rgba(10,10,10,0.1), 2px 2px 3px 0px rgba(0,0,0,0.48) inset";
            this.tab_.style.boxShadow = this.layer_frame_.style.boxShadow;
            this.Update(this.update_state_callback_, false, true);
        }
        Update(callback, is_focusin, is_focusout) {
            callback(this.user_value_, this.order_, this.layer_name_.value, this.tab_.style.backgroundColor, this.layer_lock_checkbox_.checked, this.layer_view_checkbox_.checked, is_focusin, is_focusout, this.thumbnail_.getContext('2d'));
        }
        DrawThumbnail(callback) {
            callback(this.user_value_, this.order_, this.layer_lock_checkbox_.checked, this.layer_view_checkbox_.checked, this.thumbnail_.getContext('2d'));
        }
        AddFoucsinCallback(callback) {
            this.layer_frame_.addEventListener('focusin', (event) => {
                callback(this);
            });
        }
        AddUpdateStateCallback(callback) {
            this.layer_lock_checkbox_.addEventListener('change', (event) => {
                this.Update(callback, false, false);
            });
            this.layer_view_checkbox_.addEventListener('change', (event) => {
                this.Update(callback, false, false);
            });
            this.layer_name_.addEventListener('change', (event) => {
                this.Update(callback, false, false);
            });
            this.update_state_callback_ = callback;
        }
        get order() {
            return this.order_;
        }
        set order(new_order) {
            if (new_order < 0) {
                return;
            }
            this.order_ = new_order;
            this.layer_frame_.style.order = this.order_.toString();
            this.Update(this.update_state_callback_, false, false);
        }
    }
    UiParts.LayerUi = LayerUi;
    class LayerPaneUi {
        constructor(register_callback, destructed_callback, swap_callback, updated_state_callback, draw_thumbnail_callback) {
            this.layers_ = new Array(0);
            this.frame_ = document.createElement("div");
            this.command_holder_ = document.createElement("div");
            this.new_layer_button_ = document.createElement("button");
            this.up_layer_button_ = document.createElement("button");
            this.down_layer_button_ = document.createElement("button");
            this.delete_layer_button_ = document.createElement("button");
            this.layer_holder_ = document.createElement("div");
            this.current_layer_ = null;
            this.command_holder_.style.display = "flex";
            this.command_holder_.style.backgroundColor = "rgb(95, 95, 95)";
            this.layer_holder_.style.display = "flex";
            this.layer_holder_.style.flexDirection = "column-reverse";
            this.layer_holder_.style.backgroundColor = "rgb(127, 127, 127)";
            this.new_layer_button_.innerText = "＋";
            this.up_layer_button_.innerText = "▲";
            this.down_layer_button_.innerText = "▼";
            this.delete_layer_button_.innerText = "×";
            this.new_layer_button_.addEventListener('click', (event) => {
                const registration_order = this.CalculateRegistrationOrder(this.current_layer_.order);
                const [layer_name, color, user_value] = this.register_callback_(registration_order);
                this.CreateNewLayer(this.current_layer_.order, layer_name, color, user_value);
            });
            this.up_layer_button_.addEventListener('click', (event) => {
                this.UpLayer(this.current_layer_.order);
            });
            this.down_layer_button_.addEventListener('click', (event) => {
                this.DownLayer(this.current_layer_.order);
            });
            this.delete_layer_button_.addEventListener('click', (event) => {
                if (1 < this.layers_.length) {
                    this.DeleteCurrentLayer();
                }
            });
            this.register_callback_ = register_callback;
            this.removed_callback_ = destructed_callback;
            this.swap_callback_ = swap_callback;
            this.updated_state_callback_ = updated_state_callback;
            this.draw_thumbnail_callback_ = draw_thumbnail_callback;
            this.command_holder_.appendChild(this.new_layer_button_);
            this.command_holder_.appendChild(this.up_layer_button_);
            this.command_holder_.appendChild(this.down_layer_button_);
            this.command_holder_.appendChild(this.delete_layer_button_);
            this.frame_.appendChild(this.command_holder_);
            this.frame_.appendChild(this.layer_holder_);
            return;
        }
        ChangeFocus(focus_in_layer) {
            if (focus_in_layer === this.current_layer_) {
                return;
            }
            focus_in_layer.FocusIn();
            if (this.current_layer_ !== null) {
                this.current_layer_.FocusOut();
            }
            this.current_layer_ = focus_in_layer;
            return;
        }
        SwapLayer(lh_order, rh_order) {
            let lh_layer = null;
            let rh_layer = null;
            for (let layer of this.layers_) {
                if (layer.order === lh_order) {
                    lh_layer = layer;
                }
                if (layer.order === rh_order) {
                    rh_layer = layer;
                }
                if ((lh_layer !== null) && (rh_layer !== null)) {
                    break;
                }
            }
            if (lh_layer === null) {
                return false;
            }
            if (rh_layer === null) {
                return false;
            }
            const tmp_order = lh_layer.order;
            lh_layer.order = rh_layer.order;
            rh_layer.order = tmp_order;
            return true;
        }
        CalculateRegistrationOrder(insert_target_order) {
            if (this.layers_.length === 0) {
                return 0;
            }
            return Math.min(insert_target_order, this.layers_.length - 1) + 1;
        }
        CreateNewLayer(insert_target_order, layer_name, color, user_value) {
            const registration_order = this.CalculateRegistrationOrder(insert_target_order);
            if (0 < registration_order) {
                for (let layer of this.layers_) {
                    if (registration_order <= layer.order) {
                        layer.order++;
                    }
                }
                insert_target_order += 1;
            }
            const new_layer = new LayerUi(this.layer_holder_, insert_target_order, layer_name, color, user_value);
            new_layer.AddFoucsinCallback((focus_in_layer) => { this.ChangeFocus(focus_in_layer); });
            new_layer.AddUpdateStateCallback(this.updated_state_callback_);
            this.layers_.push(new_layer);
            this.ChangeFocus(new_layer);
            return;
        }
        DeleteCurrentLayer() {
            if (this.current_layer_ === null) {
                return;
            }
            if (this.layers_.length === 1) {
                const destructed_order = this.current_layer_.order;
                const user_value = this.current_layer_.Destruct();
                this.removed_callback_(user_value, destructed_order);
                this.current_layer_ = null;
                this.layers_.splice(0, 1);
                return;
            }
            let target_index;
            for (target_index = 0; target_index < this.layers_.length; target_index++) {
                if (this.layers_[target_index] === this.current_layer_) {
                    break;
                }
            }
            this.layers_.splice(target_index, 1);
            const current_order = Math.min(this.current_layer_.order, this.layers_.length - 1);
            for (let layer of this.layers_) {
                if (current_order < layer.order) {
                    layer.order--;
                }
                if (current_order === layer.order) {
                    const destructed_order = this.current_layer_.order;
                    const user_value = this.current_layer_.Destruct();
                    this.removed_callback_(user_value, destructed_order);
                    this.current_layer_ = layer;
                }
            }
            this.current_layer_.FocusIn();
            return;
        }
        DeleteAll() {
            const num_layers = this.layers_.length;
            for (let i = 0; i < num_layers; i++) {
                this.DeleteCurrentLayer();
            }
        }
        CreateNewLayers(creation_parameters) {
            const ordered_parameters = Array(creation_parameters.length);
            for (let parameter of creation_parameters) {
                ordered_parameters[parameter[0]] = parameter;
            }
            for (let parameter of ordered_parameters) {
                parameter[0] = Math.max(0, parameter[0] - 1);
                this.CreateNewLayer(...parameter);
            }
        }
        UpLayer(target_order) {
            if (this.SwapLayer(target_order, target_order + 1)) {
                this.swap_callback_(target_order, target_order + 1);
            }
            return;
        }
        DownLayer(target_order) {
            if (this.SwapLayer(target_order, target_order - 1)) {
                this.swap_callback_(target_order, target_order - 1);
            }
            return;
        }
        Draw() {
            for (let layer of this.layers_) {
                layer.DrawThumbnail(this.draw_thumbnail_callback_);
            }
        }
        get node() {
            return this.frame_;
        }
    }
    UiParts.LayerPaneUi = LayerPaneUi;
    class DonwloadButton {
        constructor(parent, caption, dldata_request_callback) {
            this.link_ = document.createElement("a");
            this.button_ = document.createElement("button");
            this.link_.href = "#";
            this.button_.innerText = caption;
            this.button_.addEventListener('click', () => {
                const [dldata_filename, dldata_blob] = dldata_request_callback();
                const object_url = window.URL.createObjectURL(dldata_blob);
                this.link_.href = object_url;
                this.link_.download = dldata_filename;
            });
            this.link_.appendChild(this.button_);
            parent.appendChild(this.link_);
        }
    }
    UiParts.DonwloadButton = DonwloadButton;
    class ColorPaletteTableUi {
        constructor(num_cols, cell_width, cell_height, initial_color_palette_index, preset_color_palettes, select_color_callback, dad_color_cell_callback, change_color_callback) {
            this.selected_index_ = 0;
            this.preset_color_palettes_ = preset_color_palettes;
            /* for color table UI */
            this.dummy_canvas_array_ = new Array(256);
            for (let i = 0; i < 256; i++) {
                const dummy_canvas = document.createElement("canvas");
                dummy_canvas.width = cell_width - 2;
                dummy_canvas.height = cell_height - 2;
                this.dummy_canvas_array_[i] = dummy_canvas;
            }
            this.color_cells_ = new Array(256);
            const initiali_color_palette = preset_color_palettes[initial_color_palette_index].colors;
            for (let i = 0; i < 256; i++) {
                const color_cell = document.createElement("td");
                color_cell.draggable = true;
                color_cell.style.backgroundColor = initiali_color_palette[i];
                color_cell.appendChild(this.dummy_canvas_array_[i]);
                ColorPaletteTableUi.SetUnselectedColorCellStyle(color_cell);
                this.color_cells_[i] = color_cell;
            }
            ColorPaletteTableUi.SetSelectedColorCellStyle(this.color_cells_[this.selected_index_]);
            this.tr_array_ = new Array(16);
            for (let i = 0; i < 16; i++) {
                const tr = document.createElement("tr");
                for (let j = 0; j < 16; j++) {
                    const td_index = 16 * i + j;
                    tr.appendChild(this.color_cells_[td_index]);
                }
                this.tr_array_[i] = tr;
            }
            this.table_ = document.createElement("table");
            this.table_.style.borderSpacing = "0";
            for (let i = 0; i < 16; i++) {
                this.table_.appendChild(this.tr_array_[i]);
            }
            for (let i = 0; i < 256; i++) {
                this.color_cells_[i].addEventListener('click', () => {
                    select_color_callback(i);
                    ColorPaletteTableUi.SetUnselectedColorCellStyle(this.color_cells_[this.selected_index_]);
                    ColorPaletteTableUi.SetSelectedColorCellStyle(this.color_cells_[i]);
                    this.selected_index_ = i;
                    this.UpdateColorEditView();
                });
                this.color_cells_[i].addEventListener('dragstart', (event) => {
                    event.dataTransfer.setData("color_index", i.toString());
                });
                this.color_cells_[i].addEventListener('dragover', (event) => {
                    event.preventDefault();
                });
                this.color_cells_[i].addEventListener('drop', (event) => {
                    event.preventDefault();
                    const drag_color_index = parseInt(event.dataTransfer.getData("color_index"));
                    dad_color_cell_callback(drag_color_index, this.color_cells_[drag_color_index], i, this.color_cells_[i]);
                    const tmp_color = this.color_cells_[drag_color_index].style.backgroundColor;
                    this.color_cells_[drag_color_index].style.backgroundColor = this.color_cells_[i].style.backgroundColor;
                    this.color_cells_[i].style.backgroundColor = tmp_color;
                });
            }
            /* for preset color palette UI */
            this.preset_palette_selector_ = document.createElement("select");
            const none_option = document.createElement("option");
            none_option.value = "0";
            none_option.innerText = "変更しない";
            this.preset_palette_selector_.append(none_option);
            for (let i = 0; i < preset_color_palettes.length; i++) {
                const preset_option = document.createElement("option");
                preset_option.value = (i + 1).toString();
                preset_option.innerText = preset_color_palettes[i].caption;
                this.preset_palette_selector_.append(preset_option);
            }
            this.preset_palette_selector_.selectedIndex = 0;
            this.reset_color_palette_button_ = document.createElement("button");
            this.reset_color_palette_button_.innerText = "リセット";
            this.reset_color_palette_button_.addEventListener('click', (event) => {
                const preset_command_index = parseInt(this.preset_palette_selector_.value);
                if (preset_command_index === 0) {
                    return;
                }
                const preset_index = preset_command_index - 1;
                const preset_color_palette = this.preset_color_palettes_[preset_index].colors;
                for (let i = 0; i < 256; i++) {
                    const color_cell = this.color_cells_[i];
                    const color_string = preset_color_palette[i];
                    color_cell.style.backgroundColor = color_string;
                    change_color_callback(i, color_string);
                }
                this.UpdateColorEditView();
                this.preset_palette_selector_.value = "0";
            });
            /* for color edit UI */
            this.color_input_ = document.createElement("input");
            this.color_caption_ = document.createElement("div");
            this.color_caption_.style.float = "right";
            this.UpdateColorEditView();
            this.color_input_.type = "color";
            this.color_input_.addEventListener('input', (event) => {
                const i = this.selected_index_;
                const new_color_string = event.target.value;
                this.color_cells_[i].style.backgroundColor = new_color_string;
                this.UpdateColorEditCaption();
                change_color_callback(i, new_color_string);
            });
            this.preset_command_holder_ = document.createElement("div");
            this.color_table_holder_ = document.createElement("div");
            this.color_edit_holder_ = document.createElement("div");
            this.holder_ = document.createElement("div");
            this.preset_command_holder_.style.clear = "both";
            this.color_table_holder_.style.clear = "both";
            this.color_edit_holder_.style.clear = "both";
            this.holder_.style.clear = "both";
            this.preset_command_holder_.appendChild(this.preset_palette_selector_);
            this.preset_command_holder_.appendChild(this.reset_color_palette_button_);
            this.color_table_holder_.appendChild(this.table_);
            this.color_edit_holder_.appendChild(this.color_input_);
            this.color_edit_holder_.appendChild(this.color_caption_);
            this.holder_.appendChild(this.preset_command_holder_);
            this.holder_.appendChild(this.color_table_holder_);
            this.holder_.appendChild(this.color_edit_holder_);
            return;
        }
        static SetUnselectedColorCellStyle(color_cell) {
            color_cell.style.borderStyle = "solid";
            color_cell.style.borderColor = "#000000";
            color_cell.style.borderWidth = "1";
        }
        static SetSelectedColorCellStyle(color_cell) {
            color_cell.style.borderStyle = "solid";
            color_cell.style.borderColor = "#00ff00";
            color_cell.style.borderWidth = "1";
        }
        static RgbStringToHexColor(rgb_string) {
            const [r_string, g_string, b_string] = rgb_string.split('(')[1].split(')')[0].split(',');
            const r_hex = ('00' + Number(r_string).toString(16)).slice(-2);
            const g_hex = ('00' + Number(g_string).toString(16)).slice(-2);
            const b_hex = ('00' + Number(b_string).toString(16)).slice(-2);
            return `#${r_hex}${g_hex}${b_hex}`;
        }
        UpdateColorEditCaption() {
            const i = this.selected_index_;
            const color = ColorPaletteTableUi.RgbStringToHexColor(this.color_cells_[i].style.backgroundColor);
            this.color_caption_.innerText = `${i}:${color}`;
        }
        UpdateColorEditView() {
            const i = this.selected_index_;
            const color = ColorPaletteTableUi.RgbStringToHexColor(this.color_cells_[i].style.backgroundColor);
            this.color_input_.value = color;
            this.color_caption_.innerText = `${i}:${color}`;
        }
        get node() {
            return this.holder_;
        }
        GetColor(index) {
            return this.color_cells_[index].style.backgroundColor;
        }
        GetColorTable() {
            const color_table = new Array(256);
            for (let i = 0; i < 256; i++) {
                color_table[i] = this.color_cells_[i].style.backgroundColor;
            }
            return color_table;
        }
        SetColor(index, color_string) {
            this.color_cells_[index].style.backgroundColor = color_string;
            if (this.selected_index_ === index) {
                this.UpdateColorEditView();
            }
        }
        SetColorTable(color_table) {
            for (let i = 0; i < 256; i++) {
                this.color_cells_[i].style.backgroundColor = color_table[i];
            }
            this.UpdateColorEditView();
        }
        SelectColorCell(color_index) {
            ColorPaletteTableUi.SetUnselectedColorCellStyle(this.color_cells_[this.selected_index_]);
            ColorPaletteTableUi.SetSelectedColorCellStyle(this.color_cells_[color_index]);
            this.selected_index_ = color_index;
            this.UpdateColorEditView();
        }
    }
    UiParts.ColorPaletteTableUi = ColorPaletteTableUi;
    class PreviewWindowUi {
        constructor(width, height) {
            this.canvas_ = document.createElement("canvas");
            this.canvas_.width = width;
            this.canvas_.height = height;
            this.canvas_frame_ = document.createElement("div");
            this.canvas_frame_.style.overflow = "scroll";
            this.canvas_frame_.style.resize = "both";
            this.canvas_frame_.appendChild(this.canvas_);
            this.scale_selector_ = document.createElement("select");
            const scale_array = [1, 2, 3, 4, 6, 8, 12, 16, 24];
            for (let scale of scale_array) {
                const scale_option = document.createElement("option");
                scale_option.value = scale.toString();
                scale_option.innerText = `x${scale}`;
                this.scale_selector_.appendChild(scale_option);
            }
            this.command_frame_ = document.createElement("div");
            this.command_frame_.style.textAlign = "right";
            this.command_frame_.innerText = "表示倍率";
            this.command_frame_.appendChild(this.scale_selector_);
            this.holder_ = document.createElement("div");
            this.holder_.appendChild(this.command_frame_);
            this.holder_.appendChild(this.canvas_frame_);
        }
        get node() {
            return this.holder_;
        }
        Draw(pixels, color_table, width, height) {
            const view_scale = parseInt(this.scale_selector_.value);
            if (this.canvas_.width !== width * view_scale) {
                this.canvas_.width = width * view_scale;
            }
            if (this.canvas_.height !== height * view_scale) {
                this.canvas_.height = height * view_scale;
            }
            const context = this.canvas_.getContext("2d");
            context.imageSmoothingEnabled = false;
            context.setTransform(1, 0, 0, 1, 0, 0);
            context.scale(view_scale, view_scale);
            for (let h = 0; h < height; h++) {
                for (let w = 0; w < width; w++) {
                    const color_index = pixels[h][w];
                    context.fillStyle = color_table[color_index];
                    context.fillRect(w, h, 1, 1);
                }
            }
        }
    }
    UiParts.PreviewWindowUi = PreviewWindowUi;
    const CreateLeftBox = function () {
        const div = document.createElement("div");
        div.style.float = "left";
        return div;
    };
    const CreateRightBox = function () {
        const div = document.createElement("div");
        div.style.float = "right";
        return div;
    };
    const CreateText = function (text) {
        const span = document.createElement("span");
        span.innerText = text;
        return span;
    };
    class SpriteAnimationPreviewWindowUi {
        constructor(width, height) {
            this.sprite_width_ = document.createElement("input");
            this.sprite_height_ = document.createElement("input");
            this.sprite_width_.type = "number";
            this.sprite_height_.type = "number";
            this.sprite_width_.min = "1";
            this.sprite_height_.min = "1";
            this.sprite_width_.value = width.toString();
            this.sprite_height_.value = height.toString();
            this.size_frame_ = document.createElement("div");
            this.size_frame_.appendChild(CreateText("サイズ"));
            this.size_frame_.appendChild(this.sprite_width_);
            this.size_frame_.appendChild(CreateText("x"));
            this.size_frame_.appendChild(this.sprite_height_);
            this.animation_step_par_frame_ = document.createElement("input");
            this.animation_step_par_frame_.type = "number";
            this.animation_step_par_frame_.min = "1";
            this.animation_step_par_frame_.value = "1";
            this.animation_step_par_frame_holder_ = CreateLeftBox();
            this.animation_step_par_frame_holder_.appendChild(this.animation_step_par_frame_);
            this.animation_step_par_frame_holder_.appendChild(CreateText("/１コマ"));
            this.scale_selector_ = document.createElement("select");
            const scale_array = [1, 2, 3, 4, 6, 8, 12, 16, 24];
            for (let scale of scale_array) {
                const scale_option = document.createElement("option");
                scale_option.value = scale.toString();
                scale_option.innerText = `x${scale}`;
                this.scale_selector_.appendChild(scale_option);
            }
            this.scale_selector_holder_ = CreateRightBox();
            this.scale_selector_holder_.appendChild(CreateText("表示倍率"));
            this.scale_selector_holder_.appendChild(this.scale_selector_);
            this.command_frame_ = document.createElement("div");
            this.command_frame_.appendChild(this.animation_step_par_frame_holder_);
            this.command_frame_.appendChild(this.scale_selector_holder_);
            this.canvas_ = document.createElement("canvas");
            this.canvas_.width = width;
            this.canvas_.height = height;
            this.canvas_frame_ = document.createElement("div");
            this.canvas_frame_.style.overflow = "scroll";
            this.canvas_frame_.style.resize = "both";
            this.canvas_frame_.style.clear = "both";
            this.canvas_frame_.appendChild(this.canvas_);
            this.animation_playback_button_ = document.createElement("button");
            this.animation_playback_button_.innerText = "▶︎";
            this.is_playing_ = false;
            this.animation_playback_button_.addEventListener('click', (event) => {
                const button = event.target;
                button.innerText = this.is_playing_ === true ? "▶︎" : "■";
                this.is_playing_ = !this.is_playing_;
            });
            this.sprite_animation_indices_ = new Array(0);
            this.sprite_indices_ = document.createElement("textarea");
            this.sprite_indices_.style.height = "1.4em";
            this.sprite_indices_.innerText = "0";
            this.settings_frame_ = document.createElement("div");
            this.settings_frame_.appendChild(this.animation_playback_button_);
            this.settings_frame_.appendChild(this.sprite_indices_);
            this.holder_ = document.createElement("div");
            this.holder_.appendChild(this.size_frame_);
            this.holder_.appendChild(this.command_frame_);
            this.holder_.appendChild(this.canvas_frame_);
            this.holder_.appendChild(this.settings_frame_);
        }
        UpdateSpriteIndicesArray() {
            const index_strings = this.sprite_indices_.value.split(',');
            this.sprite_animation_indices_.length = 0;
            for (let index_string of index_strings) {
                const parsed = parseInt(index_string);
                if (!isNaN(parsed)) {
                    this.sprite_animation_indices_.push(parsed);
                }
            }
        }
        get node() {
            return this.holder_;
        }
        Draw(pixels, color_table, width, height, frame_count) {
            if (!this.is_playing_) {
                return;
            }
            this.UpdateSpriteIndicesArray();
            const num_indeices = this.sprite_animation_indices_.length;
            if (0 === num_indeices) {
                return;
            }
            const step_par_frame = Math.max(1, this.animation_step_par_frame_.valueAsNumber);
            const frame_number = Math.floor(frame_count / step_par_frame) % num_indeices;
            const sprite_index = this.sprite_animation_indices_[frame_number];
            const sprite_w = Math.max(1, Math.min(width, this.sprite_width_.valueAsNumber));
            const sprite_h = Math.max(1, Math.min(height, this.sprite_height_.valueAsNumber));
            const sprite_count_in_w = Math.floor(width / sprite_w);
            const sprite_count_in_h = Math.floor(height / sprite_h);
            const max_sprite_index = sprite_count_in_w * sprite_count_in_h;
            if (max_sprite_index <= sprite_index) {
                return;
            }
            const pixel_w_offset = Math.floor(sprite_index % sprite_count_in_w) * sprite_w;
            const pixel_h_offset = Math.floor(sprite_index / sprite_count_in_w) * sprite_h;
            const max_w = Math.min(pixel_w_offset + sprite_w, width);
            const max_h = Math.min(pixel_h_offset + sprite_h, height);
            const view_scale = parseInt(this.scale_selector_.value);
            if (this.canvas_.width !== sprite_w * view_scale) {
                this.canvas_.width = sprite_w * view_scale;
            }
            if (this.canvas_.height !== sprite_h * view_scale) {
                this.canvas_.height = sprite_h * view_scale;
            }
            const context = this.canvas_.getContext('2d');
            context.imageSmoothingEnabled = false;
            context.setTransform(1, 0, 0, 1, 0, 0);
            context.scale(view_scale, view_scale);
            for (let h = pixel_h_offset; h < max_h; h++) {
                for (let w = pixel_w_offset; w < max_w; w++) {
                    const color_index = pixels[h][w];
                    context.fillStyle = color_table[color_index];
                    context.fillRect(w - pixel_w_offset, h - pixel_h_offset, 1, 1);
                }
            }
            return;
        }
    }
    UiParts.SpriteAnimationPreviewWindowUi = SpriteAnimationPreviewWindowUi;
    class TabPaneUi {
        constructor() {
            if (TabPaneUi.tab_content_class_style_ === null) {
                const style = document.createElement("style");
                style.innerText
                    = `.tab_content {`
                        + `display: none;`
                        + `clear: both;`
                        + `overflow: scroll;`
                        + `resize: both;`
                        + `}`
                        + `input[name="tab_tags"] {`
                        + `display: none;`
                        + `}`
                        + `.tab_tag {`
                        + `text-align: center;`
                        + `display: block;`
                        + `float: left;`
                        + `order: -1;`
                        + `margin: 2px 2px 0px;`
                        + `}`
                        + `input:checked + .tab_tag + .tab_content {`
                        + `display: block;`
                        + `}`;
                document.getElementsByTagName("head").item(0).appendChild(style);
                TabPaneUi.tab_content_class_style_ = style;
            }
            this.tab_frame_ = document.createElement("div");
            this.tab_frame_.style.display = "grid";
            //this.tab_frame_.style.gridAutoColumns = "max-content";
            this.tab_frame_.style.gridAutoColumns = "1fr";
            this.tab_frame_.style.gridAutoRows = "max-content";
            this.tab_frame_.style.gridTemplateAreas = `"t0" "c"`;
            this.current_tab_ = null;
            this.local_tab_count_ = 0;
        }
        FitSize() {
            if (!("width" in this.current_tab_.style)) {
                return;
            }
            const contents = this.tab_frame_.getElementsByClassName("tab_content");
            const length = contents.length;
            for (let i = 0; i < length; i++) {
                contents[i].style.width = this.current_tab_.style.width;
                contents[i].style.height = this.current_tab_.style.height;
            }
            return;
        }
        AddTab(content, tab_title) {
            const tag_id = `tab_${TabPaneUi.global_tab_count_}_tag`;
            const tab_radio = document.createElement("input");
            tab_radio.type = "radio";
            tab_radio.id = tag_id;
            tab_radio.name = "tab_tags";
            const tab_label = document.createElement("label");
            tab_label.htmlFor = tag_id;
            tab_label.innerText = tab_title;
            tab_label.className = "tab_tag";
            tab_label.style.backgroundColor = content.style.backgroundColor;
            tab_label.style.gridArea = `t${this.local_tab_count_}`;
            const content_frame = document.createElement("div");
            content_frame.appendChild(content);
            content_frame.className = "tab_content";
            content_frame.style.backgroundColor = content.style.backgroundColor;
            content_frame.style.order = "1";
            content_frame.style.gridArea = "c";
            if (this.tab_frame_.childElementCount === 0) {
                tab_radio.checked = true;
                this.current_tab_ = content_frame;
            }
            tab_radio.addEventListener("change", (event) => {
                this.FitSize();
                this.current_tab_ = content_frame;
            });
            this.local_tab_count_++;
            const tag_grids = new Array(this.local_tab_count_);
            const content_grids = new Array(this.local_tab_count_);
            for (let i = 0; i < this.local_tab_count_; i++) {
                tag_grids[i] = `t${i}`;
                content_grids[i] = "c";
            }
            this.tab_frame_.style.gridTemplateAreas = `"${tag_grids.join(" ")}" "${content_grids.join(" ")}"`;
            this.tab_frame_.appendChild(tab_radio);
            this.tab_frame_.appendChild(tab_label);
            this.tab_frame_.appendChild(content_frame);
            TabPaneUi.global_tab_count_++;
            return;
        }
        get node() {
            return this.tab_frame_;
        }
    }
    TabPaneUi.tab_content_class_style_ = null;
    TabPaneUi.global_tab_count_ = 0;
    UiParts.TabPaneUi = TabPaneUi;
})(UiParts || (UiParts = {}));
/// <reference path="./windows_bitmap.ts" />
/// <reference path="./misc.ts" />
/// <reference path="./browser.ts" />
/// <reference path="./ui_parts.ts" />
/// <reference path="./canvas_tools.ts" />
class RgbColor {
    constructor(r = 0, g = 0, b = 0) {
        this.r = r;
        this.g = g;
        this.b = b;
    }
    ToHexColor() {
        const r_hex = ('00' + this.r.toString(16)).slice(-2);
        const g_hex = ('00' + this.g.toString(16)).slice(-2);
        const b_hex = ('00' + this.b.toString(16)).slice(-2);
        return `#${r_hex}${g_hex}${b_hex}`;
    }
    ToRgbString() {
        return `rgb(${this.r},${this.g},${this.b})`;
    }
    SetHexColor(hex_color) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex_color);
        if (result) {
            this.r = parseInt(result[1], 16);
            this.g = parseInt(result[2], 16);
            this.b = parseInt(result[3], 16);
        }
        return !!(result);
    }
    SetRgbString(rgb_string) {
        const result = /^rgb\s*\(\s*([\d]+)\s*,\s*([\d]+)\s*,\s*([\d]+)\s*\)/i.exec(rgb_string);
        if (result) {
            this.r = Number(result[1]);
            this.g = Number(result[2]);
            this.b = Number(result[3]);
        }
        return !!(result);
    }
    SetColorString(color_string) {
        return this.SetHexColor(color_string) ? true : this.SetRgbString(color_string);
    }
}
class PixelPoint {
    constructor(w, h) {
        this.w = w;
        this.h = h;
    }
    ToIndex(width) {
        return width * this.h + this.w;
    }
    static IndexToPixelPoint(index, width) {
        const w = Math.floor(index % width);
        const h = Math.floor(index / width);
        return new PixelPoint(w, h);
    }
    static IndexToPixelPointW(index, width) {
        return Math.floor(index % width);
    }
    static IndexToPixelPointH(index, width) {
        return Math.floor(index / width);
    }
}
const data_format_version = 1;
const view_font_size = 8;
const max_edit_width = 512;
const max_edit_height = 512;
const default_edit_width = 32;
const default_edit_height = 32;
const default_edit_scale = 8;
const large_grid_color = '#ffff00';
class EditLogger {
    constructor() {
        this.undo_stack_ = new Array(0);
        this.redo_stack_ = new Array(0);
    }
    IsUndoLogEmpty() {
        return (this.undo_stack_.length === 0) ? true : false;
    }
    IsRedoLogEmpty() {
        return (this.redo_stack_.length === 0) ? true : false;
    }
    PushUndoLog(log_data) {
        this.undo_stack_.push(log_data);
    }
    PushRedoLog(log_data) {
        this.redo_stack_.push(log_data);
    }
    PopUndoLog() {
        return this.undo_stack_.pop();
    }
    PopRedoLog() {
        return this.redo_stack_.pop();
    }
    ClearRedoLog() {
        this.redo_stack_.splice(0);
    }
}
class IndexColorBitmap {
    constructor(width, height, color_palette, pixels) {
        this.width = width;
        this.height = height;
        this.color_palette = color_palette;
        this.pixels = pixels;
    }
    ;
}
class IndexColorBitmapLayer {
}
class MultiLayerIndexColorBitmap {
    constructor() {
        this.format_version = data_format_version;
    }
}
const MargeMultiLayerIndexColorBitmapToIndexBitmap = function (mlbmp) {
    const num_layers = mlbmp.layers.length;
    const sorted_layers = new Array(num_layers);
    for (let layer of mlbmp.layers) {
        sorted_layers[num_layers - layer.order - 1] = layer;
    }
    const default_bg_color = 0;
    const max_w = mlbmp.width;
    const max_h = mlbmp.height;
    const bg_ci = default_bg_color;
    const marged_pixels = Misc.Make2dArray(max_w, max_h, 0);
    for (let h = 0; h < max_h; h++) {
        for (let w = 0; w < max_w; w++) {
            for (let i = 0; i < sorted_layers.length; i++) {
                const source_layer = sorted_layers[i];
                const src_ci = source_layer.pixels[h][w];
                if (src_ci !== bg_ci) {
                    marged_pixels[h][w] = src_ci;
                    break;
                }
            }
        }
    }
    const color_palette = new Array(256);
    for (let i = 0; i < 256; i++) {
        color_palette[i] = mlbmp.color_palette[i].ToRgbString();
    }
    return new IndexColorBitmap(max_w, max_h, color_palette, marged_pixels);
};
class PixelLayer {
    constructor(order, name, tag_color, max_width, max_height) {
        this.pixels = Misc.Make2dArray(max_width, max_height, 0);
        this.order = order;
        this.name = name;
        this.tag_color = tag_color;
        this.is_locked = false;
        this.is_locked = true;
    }
}
class Data {
    constructor(default_width, default_height, max_width, max_height) {
        this.edit_width_ = default_width;
        this.edit_height_ = default_height;
        this.current_pixel_layer_ = null;
        this.pixel_layers_ = new Map();
        this.pixels_clipboard_ = Misc.Make2dArray(max_width, max_height, 0);
        this.clipboard_stored_width_ = 0;
        this.clipboard_stored_height_ = 0;
        this.pixels_written_set_ = new Set();
        this.pixels_mask_ = Misc.Make2dArray(max_width, max_height, false);
        this.selected_color_index_ = 0;
        this.selected_bg_color_index_ = 0;
        this.color_palette_ = new Array(256);
        for (let i = 0; i < 256; i++) {
            this.color_palette_[i] = new RgbColor();
        }
        this.logger_ = new EditLogger();
    }
    SetCurrentPixelLayer(pixel_layer) {
        this.current_pixel_layer_ = pixel_layer;
    }
    IsCurrentPixelLayer(pixel_layer) {
        return (this.current_pixel_layer_ === pixel_layer);
    }
    get edit_scale() {
        return this.edit_scale_;
    }
    set edit_scale(new_scale) {
        this.edit_scale_ = new_scale;
        this.is_edit_view_touched_ = true;
    }
    get edit_width() {
        return this.edit_width_;
    }
    set edit_width(new_width) {
        this.edit_width_ = new_width;
        this.is_edit_view_touched_ = true;
    }
    get edit_height() {
        return this.edit_height_;
    }
    set edit_height(new_height) {
        this.edit_height_ = new_height;
        this.is_edit_view_touched_ = true;
    }
    get selected_color_index() {
        return this.selected_color_index_;
    }
    set selected_color_index(new_index) {
        this.selected_color_index_ = new_index;
    }
    get is_edit_view_touched() {
        return this.is_edit_view_touched_;
    }
    get selected_bg_color_index() {
        return this.selected_bg_color_index_;
    }
    AppendLayer(pixel_layer) {
        this.pixel_layers_.set(pixel_layer, pixel_layer);
    }
    RemoveLayer(pixel_layer) {
        this.pixel_layers_.delete(pixel_layer);
        if (this.current_pixel_layer_ === pixel_layer) {
            this.current_pixel_layer_ = null;
        }
    }
    RemoveAllLayers() {
        this.pixel_layers_.clear();
        this.current_pixel_layer_ = null;
    }
    TouchEditView() {
        this.is_edit_view_touched_ = true;
    }
    ClearEditViewTouchedFlag() {
        this.is_edit_view_touched_ = false;
    }
    SetMaskFlagsByRectangle(left, top, right, bottom, flag) {
        for (let h = top; h <= bottom; h++) {
            for (let w = left; w <= right; w++) {
                this.pixels_mask_[h][w] = flag;
                this.TouchPixel(w, h);
            }
        }
    }
    TurnMask() {
        for (let h = 0; h < this.edit_height_; h++) {
            for (let w = 0; w < this.edit_width_; w++) {
                this.pixels_mask_[h][w] = !this.pixels_mask_[h][w];
                this.TouchPixel(w, h);
            }
        }
    }
    IsMasked(w, h) {
        return this.pixels_mask_[h][w];
    }
    WriteMap(w, h, color_index) {
        if (this.IsMasked(w, h)) {
            return;
        }
        if (this.current_pixel_layer_.is_locked === true) {
            return;
        }
        this.current_pixel_layer_.pixels[h][w] = color_index;
        const pixel_index = this.edit_width_ * h + w;
        this.pixels_written_set_.add(pixel_index);
    }
    TouchPixel(w, h) {
        const pixel_index = this.edit_width_ * h + w;
        this.pixels_written_set_.add(pixel_index);
    }
    GetWrittenColorIndex(w, h) {
        return this.current_pixel_layer_.pixels[h][w];
    }
    GetWrittenPixelSet() {
        return this.pixels_written_set_;
    }
    SetRgbColorToPalette(index, color) {
        this.color_palette_[index].r = color.r;
        this.color_palette_[index].g = color.g;
        this.color_palette_[index].b = color.b;
    }
    GetRgbColorFromPalette(index) {
        return this.color_palette_[index];
    }
    DeleteAllUnusedColors() {
        const histogram = new Array(256).fill(0);
        for (let h = 0; h < this.edit_height_; h++) {
            for (let w = 0; w < this.edit_width_; w++) {
                histogram[this.current_pixel_layer_.pixels[h][w]]++;
            }
        }
        for (let i = 0; i < 256; i++) {
            if (histogram[i] === 0) {
                data.color_palette_[i].r = 0;
                data.color_palette_[i].g = 0;
                data.color_palette_[i].b = 0;
            }
        }
    }
    SwapColor(lh_index, rh_index) {
        if (lh_index === rh_index) {
            return;
        }
        for (let h = 0; h < this.edit_height_; h++) {
            for (let w = 0; w < this.edit_width_; w++) {
                const color_index = this.current_pixel_layer_.pixels[h][w];
                if (color_index === lh_index) {
                    this.current_pixel_layer_.pixels[h][w] = rh_index;
                    this.TouchPixel(w, h);
                }
                if (color_index === rh_index) {
                    this.current_pixel_layer_.pixels[h][w] = lh_index;
                    this.TouchPixel(w, h);
                }
            }
        }
        const tmp_color = this.color_palette_[lh_index];
        this.color_palette_[lh_index] = this.color_palette_[rh_index];
        this.color_palette_[rh_index] = tmp_color;
        return;
    }
    GetDescendingOrderedLayers() {
        const num_layers = this.pixel_layers_.size;
        const sorted_layers = new Array(num_layers);
        for (let layer of this.pixel_layers_.values()) {
            sorted_layers[num_layers - layer.order - 1] = layer;
        }
        return sorted_layers;
    }
    GetUnorderedLayersIterator() {
        return this.pixel_layers_.values();
    }
    MakeSaveData() {
        const edit_w_count = this.edit_width_;
        const edit_h_count = this.edit_height_;
        const save_pixels = new Array(edit_h_count);
        for (var h = 0; h < edit_h_count; h++) {
            save_pixels[h] = this.current_pixel_layer_.pixels[h].slice(0, edit_w_count);
        }
        const color_palette = new Array(256);
        for (var i = 0; i < 256; i++) {
            color_palette[i] = this.color_palette_[i];
        }
        const save_data = new MultiLayerIndexColorBitmap();
        save_data.width = edit_w_count;
        save_data.height = edit_h_count;
        save_data.color_palette = color_palette;
        save_data.layers = new Array(0);
        for (let layer of this.pixel_layers_.values()) {
            const save_layer = new IndexColorBitmapLayer();
            save_layer.order = layer.order;
            save_layer.name = layer.name;
            save_layer.tag_color = layer.tag_color;
            save_layer.pixels = Misc.Make2dArray(edit_w_count, edit_h_count, 0);
            for (let h = 0; h < edit_h_count; h++) {
                for (let w = 0; w < edit_w_count; w++) {
                    save_layer.pixels[h][w] = layer.pixels[h][w];
                }
            }
            save_data.layers.push(save_layer);
        }
        return save_data;
    }
    CopyFromIndexColorBitmap(bmp_data, name) {
        const edit_w = bmp_data.width;
        const edit_h = bmp_data.height;
        this.edit_width_ = edit_w;
        this.edit_height_ = edit_h;
        for (let i = 0; i < 256; i++) {
            this.color_palette_[i].SetRgbString(bmp_data.color_palette[i]);
        }
        this.pixel_layers_.clear();
        const layer = new PixelLayer(0, name, '#202020', max_edit_width, max_edit_height);
        for (let h = 0; h < edit_h; h++) {
            for (let w = 0; w < edit_w; w++) {
                layer.pixels[h][w] = bmp_data.pixels[h][w];
            }
        }
        this.pixel_layers_.set(layer, layer);
        return;
    }
    CopyFromMultiLayerIndexColorBitmap(raw_data) {
        const edit_w = raw_data.width;
        const edit_h = raw_data.height;
        this.edit_width_ = edit_w;
        this.edit_height_ = edit_h;
        for (let i = 0; i < 256; i++) {
            this.color_palette_[i].r = raw_data.color_palette[i].r;
            this.color_palette_[i].g = raw_data.color_palette[i].g;
            this.color_palette_[i].b = raw_data.color_palette[i].b;
        }
        this.pixel_layers_.clear();
        for (let raw_layer of raw_data.layers) {
            const layer = new PixelLayer(raw_layer.order, raw_layer.name, raw_layer.tag_color, max_edit_width, max_edit_height);
            for (let h = 0; h < edit_h; h++) {
                for (let w = 0; w < edit_w; w++) {
                    layer.pixels[h][w] = raw_layer.pixels[h][w];
                }
            }
            this.pixel_layers_.set(layer, layer);
        }
        return;
    }
    ApplyView() {
        ApplyLayerUi();
        this.TouchEditView();
    }
    CopyToClipBoard(left, top, right, bottom) {
        const copy_w = right - left + 1;
        const copy_h = bottom - top + 1;
        for (let dst_h = 0; dst_h < copy_h; dst_h++) {
            const src_h = top + dst_h;
            for (let dst_w = 0; dst_w < copy_w; dst_w++) {
                const src_w = left + dst_w;
                this.pixels_clipboard_[dst_h][dst_w] = this.current_pixel_layer_.pixels[src_h][src_w];
            }
        }
        this.clipboard_stored_width_ = copy_w;
        this.clipboard_stored_height_ = copy_h;
    }
    PasteToCanvas(left, top) {
        const paste_w = Math.min(this.clipboard_stored_width_, this.edit_width_ - left);
        const paste_h = Math.min(this.clipboard_stored_height_, this.edit_height_ - top);
        for (let src_h = 0; src_h < paste_h; src_h++) {
            const dst_h = top + src_h;
            for (let src_w = 0; src_w < paste_w; src_w++) {
                if (this.selected_bg_color_index_ !== this.pixels_clipboard_[src_h][src_w]) {
                    const dst_w = left + src_w;
                    data.WriteMap(dst_w, dst_h, this.pixels_clipboard_[src_h][src_w]);
                }
            }
        }
    }
    PushUndoLog() {
        const current_data = data.MakeSaveData();
        this.logger_.PushUndoLog(current_data);
        this.logger_.ClearRedoLog();
        AutoSave();
    }
    Undo() {
        if (this.logger_.IsUndoLogEmpty()) {
            return;
        }
        const current_data = data.MakeSaveData();
        this.logger_.PushRedoLog(current_data);
        const undo_data = this.logger_.PopUndoLog();
        this.CopyFromMultiLayerIndexColorBitmap(undo_data);
        this.ApplyView();
    }
    Redo() {
        if (this.logger_.IsRedoLogEmpty()) {
            return;
        }
        const current_data = data.MakeSaveData();
        this.logger_.PushUndoLog(current_data);
        const redo_data = this.logger_.PopRedoLog();
        this.CopyFromMultiLayerIndexColorBitmap(redo_data);
        this.ApplyView();
    }
}
const ApplyColorPalette = function () {
    for (let i = 0; i < 256; i++) {
        color_table.SetColor(i, data.GetRgbColorFromPalette(i).ToHexColor());
    }
};
const ApplyView = function () {
    ApplyColorPalette();
    dom.editwidth.value = data.edit_width.toString();
    dom.editheight.value = data.edit_height.toString();
    return;
};
class RectangleTargetPixels {
    constructor(x1, y1, x2, y2) {
        this.Update(x1, y1, x2, y2);
    }
    Update(x1, y1, x2, y2) {
        this.left = (x1 < x2) ? x1 : x2;
        this.right = (x1 < x2) ? x2 : x1;
        this.top = (y1 < y2) ? y1 : y2;
        this.bottom = (y1 < y2) ? y2 : y1;
    }
    In(point) {
        const is_contain = ((this.left <= point.w) && (point.w <= this.right) &&
            (this.top <= point.h) && (point.h <= this.bottom));
        return is_contain;
    }
    BrakedownToPixelMask() {
        data.SetMaskFlagsByRectangle(this.left, this.top, this.right, this.bottom, true);
    }
    Draw(canvas_context, view_scale, frame_count, hex_color) {
        const dot_span = 5;
        const edit_context = dom.edit_canvas.getContext("2d");
        edit_context.scale(1, 1);
        canvas_context = edit_context;
        let z = this.left + (frame_count % dot_span);
        canvas_context.fillStyle = hex_color;
        for (; z <= this.right; z += dot_span) {
            canvas_context.fillRect(z, this.top, 1, 1);
            data.TouchPixel(z, this.top);
        }
        z = z - this.right + this.top;
        for (; z <= this.bottom; z += dot_span) {
            canvas_context.fillRect(this.right, z, 1, 1);
            data.TouchPixel(this.right, z);
        }
        z = this.right - (z - this.bottom);
        for (; this.left <= z; z -= dot_span) {
            canvas_context.fillRect(z, this.bottom, 1, 1);
            data.TouchPixel(z, this.bottom);
        }
        z = this.bottom - (this.left - z);
        for (; this.top <= z; z -= dot_span) {
            canvas_context.fillRect(this.left, z, 1, 1);
            data.TouchPixel(this.left, z);
        }
    }
    VerticalTurn() {
        const half_h = Number(Math.floor((this.bottom - this.top + 1) / 2));
        const max_h = this.top + half_h;
        for (let h1 = this.top, h2 = this.bottom; h1 < max_h; h1++, h2--) {
            for (let w = this.left; w <= this.right; w++) {
                const c1 = data.GetWrittenColorIndex(w, h1);
                const c2 = data.GetWrittenColorIndex(w, h2);
                data.WriteMap(w, h1, c2);
                data.WriteMap(w, h2, c1);
            }
        }
    }
    HorizontalTurn() {
        const half_w = Number(Math.floor((this.right - this.left + 1) / 2));
        const max_w = this.left + half_w;
        for (let w1 = this.left, w2 = this.right; w1 < max_w; w1++, w2--) {
            for (let h = this.top; h <= this.bottom; h++) {
                const c1 = data.GetWrittenColorIndex(w1, h);
                const c2 = data.GetWrittenColorIndex(w2, h);
                data.WriteMap(w1, h, c2);
                data.WriteMap(w2, h, c1);
            }
        }
    }
    Fill() {
        const current_color_index = data.selected_color_index;
        for (let h = this.top; h <= this.bottom; h++) {
            for (let w = this.left; w <= this.right; w++) {
                data.WriteMap(w, h, current_color_index);
            }
        }
    }
    CopyToClipboard() {
        data.CopyToClipBoard(this.left, this.top, this.right, this.bottom);
    }
    Paste() {
        data.PushUndoLog();
        data.PasteToCanvas(this.left, this.top);
    }
}
const data = new Data(default_edit_width, default_edit_height, max_edit_width, max_edit_height);
const marged_pixel_layer = new PixelLayer(0, "test", '#000000', max_edit_width, max_edit_height);
const canvas_tools = new CanvasTools.CanvasTools((x, y) => {
    return !data.IsMasked(x, y);
}, (x, y) => {
    if (x < 0 || y < 0 || data.edit_width <= x || data.edit_height <= y) {
        return;
    }
    data.WriteMap(x, y, data.selected_color_index);
}, (x, y) => {
    return data.GetWrittenColorIndex(x, y);
}, () => {
    return [data.edit_width, data.edit_height];
}, () => {
    return data.edit_scale;
}, (x, y) => {
    const color_index = data.GetWrittenColorIndex(x, y);
    ChengeCurrentColor(color_index);
}, (start_x, start_y, end_x, end_y) => {
    if (target_pixels === null) {
        target_pixels = new RectangleTargetPixels(start_x, start_y, end_x, end_y);
    }
    else {
        target_pixels.Update(start_x, start_y, end_x, end_y);
    }
}, () => { }, () => {
    data.PushUndoLog();
}, () => { }, () => { });
let layer_pane_ui = null;
let target_pixels = null;
let color_table = null;
let preview_window = null;
let animation_window = null;
let preview_tab_pane = null;
const MargeLayers = function () {
    const sorted_layers = data.GetDescendingOrderedLayers();
    const max_w = data.edit_width;
    const max_h = data.edit_height;
    const bg_ci = data.selected_bg_color_index;
    const lowest_layer_index = sorted_layers.length - 1;
    for (let h = 0; h < max_h; h++) {
        for (let w = 0; w < max_w; w++) {
            let is_written = false;
            const dst_ci = marged_pixel_layer.pixels[h][w];
            for (let i = 0; i < sorted_layers.length - 1; i++) {
                const source_layer = sorted_layers[i];
                if (source_layer.is_visible === false) {
                    continue;
                }
                const src_ci = source_layer.pixels[h][w];
                if (src_ci !== bg_ci) {
                    if (src_ci !== dst_ci) {
                        marged_pixel_layer.pixels[h][w] = src_ci;
                        data.TouchPixel(w, h);
                    }
                    is_written = true;
                    break;
                }
            }
            if (!is_written) {
                if (sorted_layers[lowest_layer_index].is_visible) {
                    const src_ci = sorted_layers[lowest_layer_index].pixels[h][w];
                    if (src_ci !== dst_ci) {
                        marged_pixel_layer.pixels[h][w] = src_ci;
                        data.TouchPixel(w, h);
                    }
                }
                else {
                    if (bg_ci !== dst_ci) {
                        marged_pixel_layer.pixels[h][w] = bg_ci;
                        data.TouchPixel(w, h);
                    }
                }
            }
        }
    }
    return;
};
function GetHtmlElement(element_id) {
    return document.getElementById(element_id);
}
const FitDivWidth = function (modify_div_id, referencet_div_id) {
    const new_width = GetHtmlElement(referencet_div_id).clientWidth;
    GetHtmlElement(modify_div_id).style.width = `${new_width}px`;
};
const FitDivHeight = function (modify_div_id, referencet_div_id) {
    const new_height = GetHtmlElement(referencet_div_id).clientHeight;
    GetHtmlElement(modify_div_id).style.height = `${new_height}px`;
};
const TryReadEditDataByJson = function (bytes) {
    const read_data = JSON.parse(bytes);
    data.CopyFromMultiLayerIndexColorBitmap(read_data);
    data.ApplyView();
    ApplyView();
    return true;
};
const LoadEditData = function (bytes) {
    const bmp_data = WindowsIndexColorBitmap.Deserialize(bytes);
    if (bmp_data !== null) {
        const [color_palette, pixels, width, height] = bmp_data;
        const raw_data = new IndexColorBitmap(width, height, color_palette, pixels);
        data.CopyFromIndexColorBitmap(raw_data, dom.edit_data_name.value);
        data.ApplyView();
        ApplyView();
        return true;
    }
    const bs = Array.from(new Uint8Array(bytes), (v) => String.fromCharCode(v)).join("");
    if (TryReadEditDataByJson(bs)) {
        return true;
    }
    return false;
};
class Dom {
    Initialize() {
        this.edit_canvas = GetHtmlElement('edit');
        this.blank_frame = GetHtmlElement('blank_frame');
        this.edit_block = GetHtmlElement('editblock');
        this.edit_frame = GetHtmlElement('editframe');
        this.editwidth = GetHtmlElement('editwidth');
        this.editheight = GetHtmlElement('editheight');
        this.edit_scale = GetHtmlElement('edit_scale');
        this.edit_filepath = GetHtmlElement('edit_filepath');
        this.view_index = GetHtmlElement('view_index');
        this.view_grid = GetHtmlElement('view_grid');
        this.view_large_grid = GetHtmlElement('view_large_grid');
        this.large_grid_width = GetHtmlElement('large_grid_width');
        this.large_grid_height = GetHtmlElement('large_grid_height');
        this.dom_pen_tool = GetHtmlElement('pen_tool');
        this.dom_paint_tool = GetHtmlElement('paint_tool');
        this.dom_rectangle_select_tool = GetHtmlElement('rectangle_select_tool');
        this.grid_color = GetHtmlElement('grid_color');
        this.edit_data_name = GetHtmlElement('edit_data_name');
        this.undo_button = GetHtmlElement('undo_button');
        this.redo_button = GetHtmlElement('redo_button');
        this.rectangle_fill_button = GetHtmlElement('rectangle_fill_button');
        this.h_turn_button = GetHtmlElement('h_turn_button');
        this.v_turn_button = GetHtmlElement('v_turn_button');
        this.break_to_mask_button = GetHtmlElement('break_to_mask_button');
        this.release_targetting_button = GetHtmlElement('release_targetting_button');
        this.turn_mask_button = GetHtmlElement('turn_mask_button');
        this.delete_mask_button = GetHtmlElement('delete_mask_button');
        this.delete_all_unused_colors_button = GetHtmlElement('delete_all_unused_colors_button');
    }
}
const dom = new Dom();
const DrawLine = function (canvas_context, start_x, start_y, end_x, end_y) {
    canvas_context.moveTo(start_x, start_y);
    canvas_context.lineTo(end_x, end_y);
};
const PartiallyDrawGrid = function (canvas_context, w_grid_set, h_grid_set, width_count, height_count, scale, grid_size, grid_color) {
    canvas_context.beginPath();
    const line_height = height_count * grid_size;
    const line_width = width_count * grid_size;
    const adjust_e = -(1 / scale) / 2;
    for (let w of w_grid_set) {
        const x = (w + 1) * grid_size + adjust_e;
        DrawLine(canvas_context, x, -0.5, x, line_height + 0.5);
    }
    for (let h of h_grid_set) {
        const y = (h + 1) * grid_size + adjust_e;
        DrawLine(canvas_context, -0.5, y, line_width + 0.5, y);
    }
    canvas_context.lineWidth = 1 / scale;
    canvas_context.strokeStyle = grid_color;
    canvas_context.stroke();
};
const DrawGrid = function (canvas_context, width_count, height_count, scale, grid_size, grid_color) {
    const all_w_grid_set = new Set();
    const all_h_grid_set = new Set();
    for (var w = 0; w < width_count; w++) {
        all_w_grid_set.add(w);
    }
    for (var h = 0; h < height_count; h++) {
        all_h_grid_set.add(h);
    }
    PartiallyDrawGrid(canvas_context, all_w_grid_set, all_h_grid_set, width_count, height_count, scale, grid_size, grid_color);
};
const DrawLargeGrid = function (canvas_context, width_count, height_count, scale, grid_size, grid_color) {
    const all_w_grid_set = new Set();
    const all_h_grid_set = new Set();
    const large_grid_width = Math.min(512, Math.max(2, dom.large_grid_width.valueAsNumber));
    const large_grid_height = Math.min(512, Math.max(2, dom.large_grid_height.valueAsNumber));
    for (var w = large_grid_width; w <= width_count; w += large_grid_width) {
        all_w_grid_set.add(w - 1);
    }
    for (var h = large_grid_height; h <= height_count; h += large_grid_height) {
        all_h_grid_set.add(h - 1);
    }
    canvas_context.setLineDash([0.5, 0.5]);
    PartiallyDrawGrid(canvas_context, all_w_grid_set, all_h_grid_set, width_count, height_count, scale, grid_size, grid_color);
    canvas_context.setLineDash([]);
};
const PartiallyDrawMapchipIndex = function (edit_context, target_pixel_set, view_scale, color) {
    const font_size = view_font_size;
    edit_context.save();
    edit_context.textAlign = "center";
    edit_context.textBaseline = "middle";
    edit_context.font = `${font_size}px gothic`;
    edit_context.fillStyle = color;
    edit_context.scale(1 / view_scale, 1 / view_scale);
    const y_offset = font_size / 2;
    const width = data.edit_width;
    target_pixel_set.forEach((pixel_index) => {
        const w = PixelPoint.IndexToPixelPointW(pixel_index, width);
        const h = PixelPoint.IndexToPixelPointH(pixel_index, width);
        const dst_x = w * view_scale;
        const dst_y = h * view_scale;
        const ci = marged_pixel_layer.pixels[h][w];
        const x_offset = view_scale - String(ci).length * (font_size / 2 - 1) - 1;
        edit_context.fillText(ci.toString(), dst_x + x_offset, dst_y + y_offset);
    });
    edit_context.restore();
};
const DrawMapchipIndex = function (edit_context, edit_w_count, edit_h_count, view_scale, color) {
    const target_pixel_set = new Set();
    for (var h = 0; h < edit_h_count; h++) {
        for (var w = 0; w < edit_w_count; w++) {
            target_pixel_set.add((new PixelPoint(w, h)).ToIndex(edit_w_count));
        }
    }
    PartiallyDrawMapchipIndex(edit_context, target_pixel_set, view_scale, color);
};
const DrawCanvasPixelsPartial = function (edit_w_count, edit_h_count, view_scale) {
    const written_pixel_set = data.GetWrittenPixelSet();
    const edit_context = dom.edit_canvas.getContext("2d");
    edit_context.imageSmoothingEnabled = false;
    const update_w_grid_set = new Set();
    const update_h_grid_set = new Set();
    const pi = written_pixel_set.values[0];
    written_pixel_set.forEach((pixel_index) => {
        const w = PixelPoint.IndexToPixelPointW(pixel_index, edit_w_count);
        const h = PixelPoint.IndexToPixelPointH(pixel_index, edit_w_count);
        update_w_grid_set.add(w);
        update_h_grid_set.add(h);
        const mi = marged_pixel_layer.pixels[h][w];
        const color = data.GetRgbColorFromPalette(mi).ToHexColor();
        edit_context.fillStyle = color;
        edit_context.fillRect(w, h, 1, 1);
    });
    /* マスク表示 */
    edit_context.fillStyle = '#ff0000';
    edit_context.globalAlpha = 0.5;
    written_pixel_set.forEach((pixel_index) => {
        const w = PixelPoint.IndexToPixelPointW(pixel_index, edit_w_count);
        const h = PixelPoint.IndexToPixelPointH(pixel_index, edit_w_count);
        if (data.IsMasked(w, h)) {
            edit_context.fillRect(w, h, 1, 1);
        }
    });
    edit_context.globalAlpha = 1;
    const grid_color = dom.grid_color.value;
    if (dom.view_grid.checked) {
        PartiallyDrawGrid(edit_context, update_w_grid_set, update_h_grid_set, edit_w_count, edit_h_count, view_scale, 1, grid_color);
    }
    if (dom.view_index.checked) {
        PartiallyDrawMapchipIndex(edit_context, written_pixel_set, view_scale, grid_color);
    }
    if (dom.view_large_grid.checked) {
        DrawLargeGrid(edit_context, edit_w_count, edit_h_count, view_scale, 1, large_grid_color);
    }
    written_pixel_set.clear();
};
const DrawCanvasPixelsAll = function (edit_w_count, edit_h_count, view_scale) {
    const edit_context = dom.edit_canvas.getContext("2d");
    dom.edit_canvas.width = edit_w_count * view_scale;
    dom.edit_canvas.height = edit_h_count * view_scale;
    edit_context.imageSmoothingEnabled = false;
    edit_context.scale(view_scale, view_scale);
    for (var h = 0; h < edit_h_count; h++) {
        for (var w = 0; w < edit_w_count; w++) {
            const mi = marged_pixel_layer.pixels[h][w];
            edit_context.fillStyle = data.GetRgbColorFromPalette(mi).ToHexColor();
            edit_context.fillRect(w, h, 1, 1);
        }
    }
    /* マスク表示 */
    edit_context.fillStyle = '#ff0000';
    edit_context.globalAlpha = 0.5;
    for (var h = 0; h < edit_h_count; h++) {
        for (var w = 0; w < edit_w_count; w++) {
            if (data.IsMasked(w, h)) {
                edit_context.fillRect(w, h, 1, 1);
            }
        }
    }
    edit_context.globalAlpha = 1;
    const grid_color = dom.grid_color.value;
    if (dom.view_index.checked) {
        DrawMapchipIndex(edit_context, edit_w_count, edit_h_count, view_scale, grid_color);
    }
    if (dom.view_grid.checked) {
        DrawGrid(edit_context, edit_w_count, edit_h_count, view_scale, 1, grid_color);
    }
    if (dom.view_large_grid.checked) {
        DrawLargeGrid(edit_context, edit_w_count, edit_h_count, view_scale, 1, large_grid_color);
    }
    data.GetWrittenPixelSet().clear();
};
var frame_count = 0;
const UpdateView = function () {
    MargeLayers();
    if (data.is_edit_view_touched) {
        DrawCanvasPixelsAll(data.edit_width, data.edit_height, data.edit_scale);
        data.ClearEditViewTouchedFlag();
    }
    else {
        DrawCanvasPixelsPartial(data.edit_width, data.edit_height, data.edit_scale);
    }
    if (target_pixels !== null) {
        target_pixels.Draw(dom.edit_canvas.getContext("2d"), data.edit_scale, frame_count, '#ffffff');
        target_pixels.Draw(dom.edit_canvas.getContext("2d"), data.edit_scale, frame_count + 1, '#000000');
    }
    layer_pane_ui.Draw();
    const color_table = new Array(256);
    for (let i = 0; i < 256; i++) {
        color_table[i] = data.GetRgbColorFromPalette(i).ToHexColor();
    }
    if (preview_window !== null) {
        preview_window.Draw(marged_pixel_layer.pixels, color_table, data.edit_width, data.edit_height);
    }
    if (animation_window !== null) {
        animation_window.Draw(marged_pixel_layer.pixels, color_table, data.edit_width, data.edit_height, frame_count);
    }
    frame_count++;
    window.requestAnimationFrame(UpdateView);
};
const ChengeCurrentColor = function (new_color_index) {
    data.selected_color_index = new_color_index;
    color_table.SelectColorCell(new_color_index);
};
const AutoSave = function () {
    if (Browser.isStorageAvailable('localStorage')) {
        window.localStorage.setItem('data', JSON.stringify(data.MakeSaveData()));
    }
};
const AutoLoad = function () {
    if (Browser.isStorageAvailable('localStorage') == false) {
        return false;
    }
    const data_json = window.localStorage.getItem('data');
    if (data_json === null) {
        return false;
    }
    const load_data = JSON.parse(data_json);
    if (('format_version' in load_data) == false) {
        window.localStorage.removeItem('data');
        return false;
    }
    if (load_data.format_version !== data_format_version) {
        window.localStorage.removeItem('data');
        return false;
    }
    data.CopyFromMultiLayerIndexColorBitmap(load_data);
    return true;
};
const ApplyLayerUi = function () {
    layer_pane_ui.DeleteAll();
    const creation_parameters = new Array(0);
    for (let pixel_layer of data.GetUnorderedLayersIterator()) {
        creation_parameters.push([pixel_layer.order, pixel_layer.name, pixel_layer.tag_color, pixel_layer]);
    }
    layer_pane_ui.CreateNewLayers(creation_parameters);
    return;
};
function Initialize() {
    dom.Initialize();
    const edit_reader = new FileReader();
    dom.edit_canvas.width = 256;
    dom.edit_canvas.height = 192;
    FitDivWidth('editframe', 'editblock');
    canvas_tools.Attach(dom.edit_canvas);
    dom.editwidth.max = max_edit_width.toString();
    dom.editheight.max = max_edit_height.toString();
    dom.editwidth.value = default_edit_width.toString();
    dom.editheight.value = default_edit_height.toString();
    dom.edit_scale.value = default_edit_scale.toString();
    data.edit_width = dom.editwidth.valueAsNumber;
    data.edit_height = dom.editheight.valueAsNumber;
    data.edit_scale = Number(dom.edit_scale.value);
    dom.editwidth.addEventListener('change', (event) => {
        data.edit_width = event.target.valueAsNumber;
    });
    dom.editheight.addEventListener('change', (event) => {
        data.edit_height = event.target.valueAsNumber;
    });
    dom.edit_scale.addEventListener('change', (event) => {
        data.edit_scale = Number(event.target.value);
    });
    dom.edit_filepath.addEventListener('change', (event) => {
        edit_reader.readAsArrayBuffer(event.target.files[0]);
    });
    dom.view_index.addEventListener('change', (event) => {
        data.TouchEditView();
    });
    dom.view_grid.addEventListener('change', (event) => {
        data.TouchEditView();
    });
    dom.view_large_grid.addEventListener('change', (event) => {
        data.TouchEditView();
    });
    dom.large_grid_width.addEventListener('change', (event) => {
        data.TouchEditView();
    });
    dom.large_grid_height.addEventListener('change', (event) => {
        data.TouchEditView();
    });
    dom.grid_color.addEventListener('input', (event) => {
        data.TouchEditView();
    });
    dom.dom_pen_tool.addEventListener('change', (event) => {
        canvas_tools.tool_kind = "pen";
    });
    dom.dom_paint_tool.addEventListener('change', (event) => {
        canvas_tools.tool_kind = "paint";
    });
    dom.dom_rectangle_select_tool.addEventListener('change', (event) => {
        canvas_tools.tool_kind = "rectangle_select";
    });
    const dl_button = new UiParts.DonwloadButton(GetHtmlElement("edit_command"), "保存（ダウンロード）", () => {
        const basename = dom.edit_data_name.value;
        const save_format = GetHtmlElement('edit_save_format').value;
        return MakeSaveData(basename, save_format);
    });
    edit_reader.addEventListener('load', (event) => {
        const basename = Misc.ExtractBaseName(dom.edit_filepath.value);
        dom.edit_data_name.value = basename;
        LoadEditData(event.target.result);
        data.TouchEditView();
    });
    let creation_count = 0;
    const MakeLayerDefaultName = function () {
        const hue = (creation_count * 79) % 360;
        const color = new RgbColor(...Misc.HsvToRgb(hue, 0.375, 0.75));
        const name = `new layer #${creation_count}`;
        creation_count++;
        return [name, color.ToHexColor()];
    };
    color_table = new UiParts.ColorPaletteTableUi(16, 16, 16, 0, [
        { caption: "HSV 16色", colors: Misc.MakeHSVBalancedColorList(1) },
        { caption: "HSV 16色2彩度", colors: Misc.MakeHSVBalancedColorList(2) },
        { caption: "HSV 16色4彩度", colors: Misc.MakeHSVBalancedColorList(4) },
        { caption: "Webセーフカラー", colors: Misc.MakeWebSafeColorList() },
    ], (color_index) => {
        data.selected_color_index = color_index;
    }, (src_i, src_cc, dst_i, dst_cc) => {
        data.SwapColor(src_i, dst_i);
    }, (color_index, color_string) => {
        data.GetRgbColorFromPalette(color_index).SetHexColor(color_string);
        data.TouchEditView();
    });
    document.getElementById("colorpalette").appendChild(color_table.node);
    if (!AutoLoad()) {
        data.RemoveAllLayers();
        const pixel_layer = new PixelLayer(0, ...MakeLayerDefaultName(), max_edit_width, max_edit_height);
        data.AppendLayer(pixel_layer);
    }
    ApplyView();
    dom.undo_button.addEventListener('click', (event) => {
        data.Undo();
        ApplyView();
    });
    dom.redo_button.addEventListener('click', (event) => {
        data.Redo();
        ApplyView();
    });
    dom.rectangle_fill_button.addEventListener('click', (event) => {
        if (target_pixels !== null) {
            data.PushUndoLog();
            target_pixels.Fill();
        }
    });
    dom.v_turn_button.addEventListener('click', (event) => {
        if (target_pixels !== null) {
            target_pixels.VerticalTurn();
        }
    });
    dom.h_turn_button.addEventListener('click', (event) => {
        if (target_pixels !== null) {
            target_pixels.HorizontalTurn();
        }
    });
    dom.break_to_mask_button.addEventListener('click', (event) => {
        if (target_pixels !== null) {
            target_pixels.BrakedownToPixelMask();
        }
    });
    dom.release_targetting_button.addEventListener('click', (event) => {
        target_pixels = null;
    });
    dom.turn_mask_button.addEventListener('click', (event) => {
        data.TurnMask();
    });
    dom.delete_mask_button.addEventListener('click', (event) => {
        data.SetMaskFlagsByRectangle(0, 0, data.edit_width, data.edit_height, false);
    });
    dom.delete_all_unused_colors_button.addEventListener('click', (event) => {
        data.DeleteAllUnusedColors();
        ApplyColorPalette();
    });
    const layers = document.getElementById("layerblock");
    layer_pane_ui = new UiParts.LayerPaneUi((order) => {
        const param = MakeLayerDefaultName();
        const new_pixel_layer = new PixelLayer(order, ...param, max_edit_width, max_edit_height);
        data.AppendLayer(new_pixel_layer);
        return [...param, new_pixel_layer];
    }, (pixel_layer, order) => {
        data.RemoveLayer(pixel_layer);
    }, (lh_order, rh_order) => { }, (pixel_layer, order, name, tag_color, is_locked, is_visible, is_focusin, is_focusout, thumbnail_context) => {
        pixel_layer.order = order;
        pixel_layer.name = name;
        pixel_layer.is_locked = is_locked;
        pixel_layer.is_visible = is_visible;
        if (is_focusin === true) {
            data.SetCurrentPixelLayer(pixel_layer);
            dom.edit_block.style.backgroundColor = tag_color;
            dom.edit_frame.style.backgroundColor = tag_color;
        }
        if (data.IsCurrentPixelLayer(pixel_layer)) {
            if (is_locked) {
                dom.edit_canvas.style.cursor = 'not-allowed';
            }
            else {
                dom.edit_canvas.style.cursor = 'auto';
            }
        }
    }, (value, order, is_locked, is_visible, thumbnail_context) => {
        thumbnail_context.scale(1, 1);
        thumbnail_context.fillStyle = '#000000';
        thumbnail_context.fillRect(0, 0, 16, 16);
        if (is_locked) {
            thumbnail_context.moveTo(0.5, 0.5);
            thumbnail_context.lineTo(15.5, 15.5);
            thumbnail_context.lineWidth = 3;
            thumbnail_context.strokeStyle = '#ff0000';
            thumbnail_context.stroke();
        }
    });
    layers.appendChild(layer_pane_ui.node);
    ApplyLayerUi();
    preview_tab_pane = new UiParts.TabPaneUi();
    preview_window = new UiParts.PreviewWindowUi(data.edit_width, data.edit_height);
    animation_window = new UiParts.SpriteAnimationPreviewWindowUi(16, 16);
    preview_window.node.style.backgroundColor = "darkgoldenrod";
    animation_window.node.style.backgroundColor = "olive";
    preview_tab_pane.AddTab(preview_window.node, "プレビュー");
    preview_tab_pane.AddTab(animation_window.node, "アニメ");
    document.getElementById("viewblock").appendChild(preview_tab_pane.node);
    window.addEventListener('keydown', (event) => {
        if (event.ctrlKey) {
            switch (event.key) {
                case 's':
                    AutoSave();
                    break;
                case 'z':
                    data.Undo();
                    ApplyView();
                    break;
                case 'y':
                    data.Redo();
                    ApplyView();
                    break;
                case 'd':
                    target_pixels = null;
                    break;
                case 'c':
                    if (!!target_pixels) {
                        target_pixels.CopyToClipboard();
                    }
                    break;
                case 'v':
                    if (!!target_pixels) {
                        target_pixels.Paste();
                    }
                    else {
                        data.PushUndoLog();
                        data.PasteToCanvas(0, 0);
                    }
                    break;
            }
        }
    });
    window.requestAnimationFrame(UpdateView);
}
const MakeSaveDataBlobAsWindowsIndexColorBitmap = function () {
    const save_data = data.MakeSaveData();
    const index_bmp = MargeMultiLayerIndexColorBitmapToIndexBitmap(save_data);
    const bmp_bytes = WindowsIndexColorBitmap.Serialize(index_bmp.color_palette, index_bmp.pixels, index_bmp.width, index_bmp.height);
    const save_data_blob = new Blob([bmp_bytes]);
    return save_data_blob;
};
const MakeSaveDataBlobAsJson = function () {
    const save_data = data.MakeSaveData();
    const save_data_json = JSON.stringify(save_data);
    const save_data_blob = new Blob([save_data_json], {
        type: 'application/json'
    });
    return save_data_blob;
};
const MakeSaveData = function (basename, save_format) {
    switch (save_format) {
        case "WindowsIndexColorBitmap":
            return [`${basename}.bmp`, MakeSaveDataBlobAsWindowsIndexColorBitmap()];
        case "JSON":
        default:
            return [`${basename}.json`, MakeSaveDataBlobAsJson()];
    }
};
Initialize();

/******/ })()
;</script></body>

</html>