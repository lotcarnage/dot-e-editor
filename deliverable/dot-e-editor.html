<!DOCTYPE html>
<html lang="ja">

<head>
    <title>ドット絵エディター</title>
    <meta charset="UTF-8">
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        body {
            background-color: darkslategrey;
        }

        input[type="number"] {
            width: 64px;
            text-align: right;
        }

        div.layout {
            display: grid;
            grid-template-columns: max-content auto auto max-content;
            grid-template-rows: max-content 340px;
            grid-template-areas:
                "a b b b"
                "d e e c"
                "d e e g"
                "d e e g";
        }

        div.hbox {
            clear: both;
        }

        div.vbox {
            float: left;
        }

        div.rightvbox {
            float: right;
        }

        div.canvasframe {
            overflow: scroll;
            resize: both;
            clear: both;
        }

        div.overflow_frame {
            padding: 24px;
            width: max-content;
            height: max-content;
        }

        div#settingsblock {
            grid-area: a;
            background-color: darkgrey;
        }

        div#toolsblock {
            grid-area: b;
            background-color: skyblue;
        }

        div#paletteblock {
            grid-area: c;
            background-color: darkseagreen;
            height: max-content;
        }

        div#viewblock {
            grid-area: d;
        }

        div#viewframe {
            width: 200px;
            height: 200px;
        }

        div#editblock {
            grid-area: e;
            background-color: mediumpurple;
        }

        div#editframe {
            width: 128px;
            height: 384px;
        }

        div#layerblock {
            grid-area: g;
            background-color: yellowgreen;
        }

        div#manualblock {
            background-color: darkslategrey;
        }
    </style>
</head>

<body>
    <div class="layout">
        <div id="viewblock"></div>
        <div id="layerblock"></div>
        <div class="vbox" id="settingsblock">
            <div class="hbox">
                <span>大グリッドサイズ</span>
            </div>
            <div class="hbox">
                <input type="number" id="large_grid_width" min="2" max="512" value="16">
                <input type="number" id="large_grid_height" min="2" max="512" value="16">
            </div>
            <div class="hbox">
                <label for="grid_color">グリッド／番号色</label>
                <input type="color" id="grid_color" value="#333333">
            </div>
        </div>
        <div id="toolsblock">
            <div class="vbox">
                <div class="hbox">
                    <button id="rectangle_fill_button">矩形塗り潰し</button>
                    <button id="v_turn_button">上下反転</button>
                    <button id="h_turn_button">左右反転</button>
                    <button id="break_to_mask_button">マスク化</button>
                    <button id="turn_mask_button">マスク反転</button>
                    <button id="delete_mask_button">マスク消去</button>
                    <button id="release_targetting_button">選択解除</button>
                </div>
                <div id="toolpanel"></div>
                <div class="hbox">
                    <button id="undo_button">Undo</button>
                    <button id="redo_button">Redo</button>
                    <button id="clear_button">Clear</button>
                </div>
            </div>
            <div class="vbox">
                <div id="tooloptions"></div>
            </div>
        </div>

        <div id="paletteblock">
            <div class="hbox" id="colorpalette">
            </div>
            <div class="rightvbox">
                <button id="delete_all_unused_colors_button">未使用色を全削除</button>
            </div>
        </div>
        <div id="editblock">
            <div class="hbox">
                読み込み<input type="file" id="edit_filepath">
            </div>
            <div class="hbox" id="edit_command">
                保存形式
                <select id="edit_save_format">
                    <option value="JSON" selected>JSON</option>
                    <option value="WindowsIndexColorBitmap">BMP</option>
                </select>
                <input type="text" id="edit_data_name" value="new_picture">
            </div>
        </div>
    </div>
    <div id="manualblock">
        <details>
            <summary>操作方法など</summary>
            <h3>ショートカット</h3>
            <ul>
                <li>Ctrl+s:ローカルストレージに上書き保存</li>
                <li>Ctrl+d:選択範囲解除</li>
                <li>Ctrl+c:選択範囲をコピー</li>
                <li>Ctrl+v:コピー内容をペースト</li>
                <li>Ctrl+z:元に戻す(Undo)</li>
                <li>Ctrl+y:やり直す(Redo)</li>
            </ul>
            <h3>ツール類</h3>
            <h4>ペン</h4>
            <ul>
                <li>右ボタンクリック：スポイト機能</li>
            </ul>
            <h4>塗り潰し</h4>
            <ul>
                <li>右ボタンクリック：スポイト機能</li>
            </ul>
            <h3>アニメーションプレビュー</h3>
            <p>システムはユーザーに指定されたスプライトサイズでキャンバスを分割し、ラスタ方向へスプライトインデックスを自動で割り付ける。</p>
            <p>テキストエリアにカンマ(,)区切りでスプライトインデックス（0〜）を指定する事で、指定した順にスプライトアニメーション表示する。</p>
            <p>毎秒約60フレーム描画しており、1コマに何フレームかけるか設定する事で、アニメーション速度を調整できる。</p>
        </details>
    </div>
<script>/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./built/browser.js":
/*!**************************!*\
  !*** ./built/browser.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Browser": () => (/* binding */ Browser)
/* harmony export */ });
var Browser;
(function (Browser) {
    function isStorageAvailable(type) {
        let storage;
        try {
            storage = window[type];
            const x = '__storage_test__';
            storage.setItem(x, x);
            storage.removeItem(x);
            return true;
        }
        catch (e) {
            return (e instanceof DOMException) && (
            // everything except Firefox
            e.code === 22 ||
                // Firefox
                e.code === 1014 ||
                // test name field too, because code might not be present
                // everything except Firefox
                e.name === 'QuotaExceededError' ||
                // Firefox
                e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&
                // acknowledge QuotaExceededError only if there's something already stored
                (storage && storage.length !== 0);
        }
    }
    Browser.isStorageAvailable = isStorageAvailable;
})(Browser || (Browser = {}));


/***/ }),

/***/ "./built/canvas_tools.js":
/*!*******************************!*\
  !*** ./built/canvas_tools.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PixelPoint": () => (/* binding */ PixelPoint),
/* harmony export */   "CanvasTools": () => (/* binding */ CanvasTools)
/* harmony export */ });
/* harmony import */ var _misc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./misc */ "./built/misc.js");

class PixelPoint {
    constructor(w, h) {
        this.w = w;
        this.h = h;
    }
    ToIndex(width) {
        return width * this.h + this.w;
    }
    static IndexToPixelPoint(index, width) {
        const w = Math.floor(index % width);
        const h = Math.floor(index / width);
        return new PixelPoint(w, h);
    }
    static IndexToPixelPointW(index, width) {
        return Math.floor(index % width);
    }
    static IndexToPixelPointH(index, width) {
        return Math.floor(index / width);
    }
}
var CanvasTools;
(function (CanvasTools_1) {
    class Tool {
        LeftButtonDown(pixel_w, pixel_h) { }
        ;
        LeftButtonUp(pixel_w, pixel_h) { }
        ;
        RightButtonDown(pixel_w, pixel_h) { }
        ;
        RightButtonUp(pixel_w, pixel_h) { }
        ;
        MouseMove(pixel_w, pixel_h) { }
        ;
        MouseOut(pixel_w, pixel_h) { }
        ;
    }
    CanvasTools_1.Tool = Tool;
    class CallbackTable {
        constructor(is_pixel_writable_cb_, write_pixel_cb_, get_pixel_cb_, get_canvas_size_cb_, get_view_scale_cb_, color_picker_cb_, select_area_update_cb_, begin_cb_, prechange_cb_, postchange_cb_, end_cb_) {
            this.is_pixel_writable_cb_ = is_pixel_writable_cb_;
            this.write_pixel_cb_ = write_pixel_cb_;
            this.get_pixel_cb_ = get_pixel_cb_;
            this.get_canvas_size_cb_ = get_canvas_size_cb_;
            this.get_view_scale_cb_ = get_view_scale_cb_;
            this.color_picker_cb_ = color_picker_cb_;
            this.select_area_update_cb_ = select_area_update_cb_;
            this.begin_cb_ = begin_cb_;
            this.prechange_cb_ = prechange_cb_;
            this.postchange_cb_ = postchange_cb_;
            this.end_cb_ = end_cb_;
        }
    }
    CanvasTools_1.CallbackTable = CallbackTable;
    class PenTool extends Tool {
        constructor(cb_table) {
            super();
            this.is_activated = false;
            this.cb_table_ = cb_table;
        }
        LeftButtonDown(pixel_w, pixel_h) {
            this.cb_table_.begin_cb_();
            this.cb_table_.prechange_cb_();
            this.cb_table_.write_pixel_cb_(pixel_w, pixel_h);
            this.last_point_w = pixel_w;
            this.last_point_h = pixel_h;
            this.is_activated = true;
            return;
        }
        ;
        LeftButtonUp(pixel_w, pixel_h) {
            this.is_activated = false;
            this.cb_table_.postchange_cb_();
            this.cb_table_.end_cb_();
        }
        RightButtonDown(pixel_w, pixel_h) {
            this.cb_table_.color_picker_cb_(pixel_w, pixel_h);
            return;
        }
        ;
        MouseMove(pixel_w, pixel_h) {
            if (this.is_activated) {
                _misc__WEBPACK_IMPORTED_MODULE_0__.Misc.LineTo2d(this.last_point_w, this.last_point_h, pixel_w, pixel_h, this.cb_table_.write_pixel_cb_);
            }
            else {
                this.cb_table_.begin_cb_();
                this.cb_table_.prechange_cb_();
            }
            this.last_point_w = pixel_w;
            this.last_point_h = pixel_h;
            this.is_activated = true;
            return;
        }
        ;
        MouseOut(pixel_w, pixel_h) {
            if (this.is_activated) {
                _misc__WEBPACK_IMPORTED_MODULE_0__.Misc.LineTo2d(this.last_point_w, this.last_point_h, pixel_w, pixel_h, this.cb_table_.write_pixel_cb_);
            }
            this.is_activated = false;
        }
        ;
    }
    CanvasTools_1.PenTool = PenTool;
    class PaintTool extends Tool {
        constructor(cb_table) {
            super();
            this.cb_table_ = cb_table;
        }
        ExtractRegionPixelSet(start_point, max_w, max_h) {
            const min_w = 0;
            const min_h = 0;
            const region_pixels = new Set();
            const next_pixel_queue = new Array();
            const target_color_index = this.cb_table_.get_pixel_cb_(start_point.w, start_point.h);
            region_pixels.add(start_point.ToIndex(max_w));
            next_pixel_queue.push(start_point);
            const AddPixelToRegion = (new_point) => {
                if (this.cb_table_.get_pixel_cb_(new_point.w, new_point.h) !== target_color_index) {
                    return;
                }
                if (region_pixels.has(new_point.ToIndex(max_w))) {
                    return;
                }
                next_pixel_queue.push(new_point);
                region_pixels.add(new_point.ToIndex(max_w));
                return;
            };
            for (;;) {
                if (next_pixel_queue.length === 0) {
                    break;
                }
                let pixel = next_pixel_queue.shift();
                if (min_h < pixel.h) {
                    if (this.cb_table_.is_pixel_writable_cb_(pixel.w + 0, pixel.h - 1)) {
                        AddPixelToRegion(new PixelPoint(pixel.w + 0, pixel.h - 1));
                    }
                }
                if (min_w < pixel.w) {
                    if (this.cb_table_.is_pixel_writable_cb_(pixel.w - 1, pixel.h + 0)) {
                        AddPixelToRegion(new PixelPoint(pixel.w - 1, pixel.h + 0));
                    }
                }
                if (pixel.w < max_w - 1) {
                    if (this.cb_table_.is_pixel_writable_cb_(pixel.w + 1, pixel.h + 0)) {
                        AddPixelToRegion(new PixelPoint(pixel.w + 1, pixel.h + 0));
                    }
                }
                if (pixel.h < max_h - 1) {
                    if (this.cb_table_.is_pixel_writable_cb_(pixel.w + 0, pixel.h + 1)) {
                        AddPixelToRegion(new PixelPoint(pixel.w + 0, pixel.h + 1));
                    }
                }
            }
            return region_pixels;
        }
        ;
        LeftButtonDown(pixel_w, pixel_h) {
            this.cb_table_.begin_cb_();
            this.cb_table_.prechange_cb_();
            const selected_pixel = new PixelPoint(pixel_w, pixel_h);
            const [max_w, max_h] = this.cb_table_.get_canvas_size_cb_();
            const region_pixel_set = this.ExtractRegionPixelSet(selected_pixel, max_w, max_h);
            region_pixel_set.forEach((pixel_index) => {
                const w = PixelPoint.IndexToPixelPointW(pixel_index, max_w);
                const h = PixelPoint.IndexToPixelPointH(pixel_index, max_w);
                this.cb_table_.write_pixel_cb_(w, h);
            });
            this.cb_table_.postchange_cb_();
            this.cb_table_.end_cb_();
        }
        ;
        RightButtonDown(x, y) {
            this.cb_table_.color_picker_cb_(x, y);
        }
        ;
    }
    CanvasTools_1.PaintTool = PaintTool;
    class RectangleSelectTool extends Tool {
        constructor(cb_table) {
            super();
            this.start_x = 0;
            this.start_y = 0;
            this.cb_table_ = cb_table;
        }
        LeftButtonDown(start_x, start_y) {
            this.start_x = start_x;
            this.start_y = start_y;
            this.cb_table_.select_area_update_cb_(this.start_x, this.start_y, this.start_x, this.start_y);
        }
        ;
        MouseMove(end_x, end_y) {
            this.cb_table_.select_area_update_cb_(this.start_x, this.start_y, end_x, end_y);
            return;
        }
        ;
    }
    CanvasTools_1.RectangleSelectTool = RectangleSelectTool;
    class CanvasTools {
        constructor(is_pixel_writable_cb_, write_pixel_cb_, get_pixel_cb_, get_canvas_size_cb_, get_view_scale_cb_, color_picker_cb_, select_area_update_cb_, begin_cb_, prechange_cb_, postchange_cb_, end_cb_) {
            this.cb_table_ = new CallbackTable(is_pixel_writable_cb_, write_pixel_cb_, get_pixel_cb_, get_canvas_size_cb_, get_view_scale_cb_, color_picker_cb_, select_area_update_cb_, begin_cb_, prechange_cb_, postchange_cb_, end_cb_);
            this.pen_tool_ = new PenTool(this.cb_table_);
            this.paint_tool_ = new PaintTool(this.cb_table_);
            this.rectangle_select_tool_ = new RectangleSelectTool(this.cb_table_);
            this.current_tool_ = this.pen_tool_;
        }
        static GetPixelPoint(event, block_size) {
            const rect = event.target.getBoundingClientRect();
            const w = Math.floor((event.clientX - rect.left) / block_size);
            const h = Math.floor((event.clientY - rect.top) / block_size);
            return [w, h];
        }
        ;
        static GetTouchPixelPoint(event, block_size) {
            const rect = event.target.getBoundingClientRect();
            const w = Math.floor((event.touches[0].clientX - rect.left) / block_size);
            const h = Math.floor((event.touches[0].clientY - rect.top) / block_size);
            return [w, h];
        }
        ;
        MouseDownCallback(event) {
            if (event.button === 0) {
                this.current_tool_.LeftButtonDown(...CanvasTools.GetPixelPoint(event, this.cb_table_.get_view_scale_cb_()));
            }
            else if (event.button === 2) {
                this.current_tool_.RightButtonDown(...CanvasTools.GetPixelPoint(event, this.cb_table_.get_view_scale_cb_()));
            }
        }
        ;
        MouseUpCallback(event) {
            if (event.button === 0) {
                this.current_tool_.LeftButtonUp(...CanvasTools.GetPixelPoint(event, this.cb_table_.get_view_scale_cb_()));
            }
            else if (event.button === 2) {
                this.current_tool_.RightButtonUp(...CanvasTools.GetPixelPoint(event, this.cb_table_.get_view_scale_cb_()));
            }
        }
        ;
        MouseMoveCallback(event) {
            if (event.buttons === 0x01) {
                this.current_tool_.MouseMove(...CanvasTools.GetPixelPoint(event, this.cb_table_.get_view_scale_cb_()));
            }
        }
        ;
        MouseOutCallback(event) {
            if (event.buttons === 0x01) {
                this.current_tool_.MouseOut(...CanvasTools.GetPixelPoint(event, this.cb_table_.get_view_scale_cb_()));
            }
        }
        ;
        TouchStartCallback(event) {
            if (event.touches.length === 1) {
                this.current_tool_.LeftButtonDown(...CanvasTools.GetTouchPixelPoint(event, this.cb_table_.get_view_scale_cb_()));
            }
        }
        ;
        TouchEndCallback(event) {
            if (event.touches.length === 1) {
                this.current_tool_.LeftButtonUp(...CanvasTools.GetTouchPixelPoint(event, this.cb_table_.get_view_scale_cb_()));
            }
        }
        ;
        TouchMoveCallback(event) {
            if (event.touches.length === 1) {
                this.current_tool_.MouseMove(...CanvasTools.GetTouchPixelPoint(event, this.cb_table_.get_view_scale_cb_()));
            }
            event.preventDefault();
        }
        ;
        Attach(canvas) {
            canvas.addEventListener('mousedown', (event) => { this.MouseDownCallback(event); });
            canvas.addEventListener('mouseup', (event) => { this.MouseUpCallback(event); });
            canvas.addEventListener('contextmenu', (event) => { this.MouseDownCallback(event); });
            canvas.addEventListener('mousemove', (event) => { this.MouseMoveCallback(event); });
            canvas.addEventListener('mouseout', (event) => { this.MouseOutCallback(event); });
            canvas.addEventListener('touchstart', (event) => { this.TouchStartCallback(event); });
            canvas.addEventListener('touchend', (event) => { this.TouchEndCallback(event); });
            canvas.addEventListener('touchmove', (event) => { this.TouchMoveCallback(event); });
        }
        set tool_kind(kind) {
            switch (kind) {
                case "pen":
                    this.current_tool_ = this.pen_tool_;
                    break;
                case "paint":
                    this.current_tool_ = this.paint_tool_;
                    break;
                case "rectangle_select":
                    this.current_tool_ = this.rectangle_select_tool_;
                    break;
            }
        }
    }
    CanvasTools_1.CanvasTools = CanvasTools;
})(CanvasTools || (CanvasTools = {}));


/***/ }),

/***/ "./built/dom/dom.js":
/*!**************************!*\
  !*** ./built/dom/dom.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Dom": () => (/* binding */ Dom)
/* harmony export */ });
var Dom;
(function (Dom) {
    function CreateSelector(items, ToCaptionCallback, selected_index) {
        const selector = document.createElement("select");
        for (let i = 0; i < items.length; i++) {
            const preset_option = document.createElement("option");
            preset_option.value = items[i].toString();
            preset_option.innerText = ToCaptionCallback(i, items[i]);
            selector.append(preset_option);
        }
        selector.selectedIndex = selected_index;
        return selector;
    }
    Dom.CreateSelector = CreateSelector;
    function CreateText(text) {
        const span = document.createElement("span");
        span.innerText = text;
        return span;
    }
    Dom.CreateText = CreateText;
    function CreateButton(caption, ClickEventCallback) {
        const button = document.createElement("button");
        button.innerText = caption;
        button.addEventListener('click', (event) => {
            const buttonElement = event.target;
            ClickEventCallback(buttonElement);
            return;
        });
        return button;
    }
    Dom.CreateButton = CreateButton;
    function CreateCheckBox(checkbox_id, label_content) {
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.id = checkbox_id;
        const label = document.createElement("label");
        label.htmlFor = checkbox.id;
        label.appendChild(label_content);
        return [checkbox, label];
    }
    Dom.CreateCheckBox = CreateCheckBox;
    function CreateNumberInput(minimum, maximum, value) {
        const element = document.createElement("input");
        element.type = "number";
        element.min = minimum.toString();
        element.max = maximum.toString();
        element.value = value.toString();
        return element;
    }
    Dom.CreateNumberInput = CreateNumberInput;
})(Dom || (Dom = {}));
;


/***/ }),

/***/ "./built/gui/canvas.js":
/*!*****************************!*\
  !*** ./built/gui/canvas.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CanvasUi": () => (/* binding */ CanvasUi)
/* harmony export */ });
/* harmony import */ var _dom_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom/dom */ "./built/dom/dom.js");

class CanvasUi {
    constructor(width, height, resize_cb) {
        /* for Canvas Size */
        this.canvas_width_spin_ = _dom_dom__WEBPACK_IMPORTED_MODULE_0__.Dom.CreateNumberInput(1, 512, width);
        this.canvas_height_spin_ = _dom_dom__WEBPACK_IMPORTED_MODULE_0__.Dom.CreateNumberInput(1, 512, height);
        /* 最初の描画のために必ず差分が発生するように初期化しておく */
        this.last_width_ = 0;
        this.last_height_ = 0;
        /* view grid checkbox */
        [this.small_grid_view_, this.small_grid_label_] = _dom_dom__WEBPACK_IMPORTED_MODULE_0__.Dom.CreateCheckBox(`canvasui_sg_${CanvasUi.count_}`, CanvasUi.CreateSmallGridIcon(24));
        [this.large_grid_view_, this.large_grid_label_] = _dom_dom__WEBPACK_IMPORTED_MODULE_0__.Dom.CreateCheckBox(`canvasui_lg_${CanvasUi.count_}`, CanvasUi.CreateLargeGridIcon(24));
        [this.color_index_view_, this.color_index_label_] = _dom_dom__WEBPACK_IMPORTED_MODULE_0__.Dom.CreateCheckBox(`canvasui_ci_${CanvasUi.count_}`, _dom_dom__WEBPACK_IMPORTED_MODULE_0__.Dom.CreateText("色番号"));
        this.last_small_grid_view_ = false;
        this.last_large_grid_view_ = false;
        this.last_color_index_view_ = false;
        this.last_large_grid_width_ = 0;
        this.last_large_grid_height_ = 0;
        this.last_small_grid_color_ = '#000000';
        /* for Scale selector */
        this.scale_selector_ = _dom_dom__WEBPACK_IMPORTED_MODULE_0__.Dom.CreateSelector([1, 2, 4, 8, 12, 16, 20, 24, 28, 32], (index, item) => { return `x${item}`; }, 0);
        this.last_scale_ = 1;
        /* settings holder */
        this.settings_holder_ = document.createElement("div");
        this.settings_holder_.appendChild(this.canvas_width_spin_);
        this.settings_holder_.appendChild(this.canvas_height_spin_);
        this.settings_holder_.appendChild(this.small_grid_view_);
        this.settings_holder_.appendChild(this.small_grid_label_);
        this.settings_holder_.appendChild(this.large_grid_view_);
        this.settings_holder_.appendChild(this.large_grid_label_);
        this.settings_holder_.appendChild(this.color_index_view_);
        this.settings_holder_.appendChild(this.color_index_label_);
        this.settings_holder_.appendChild(this.scale_selector_);
        this.settings_holder_.style.backgroundColor = "gray";
        this.settings_holder_.style.display = "flex";
        this.settings_holder_.style.padding = "2px 0px 2px 2px";
        /* for Canvas */
        this.canvas_ = document.createElement("canvas");
        this.canvas_.width = width;
        this.canvas_.height = height;
        this.canvas_.addEventListener("contextmenu", (event) => {
            event.preventDefault();
            return false;
        });
        this.canvas_box_ = document.createElement("div");
        this.canvas_box_.style.width = "max-content";
        this.canvas_box_.style.height = "max-content";
        this.canvas_frame_ = document.createElement("div");
        this.canvas_frame_.style.overflow = "scroll";
        this.canvas_frame_.style.resize = "both";
        this.canvas_frame_.style.clear = "both";
        this.canvas_box_.appendChild(this.canvas_);
        this.canvas_frame_.appendChild(this.canvas_box_);
        this.last_pixels_ = JSON.parse(JSON.stringify((new Array(512)).fill((new Array(512)).fill(0))));
        this.last_pixel_mask_ = JSON.parse(JSON.stringify((new Array(512)).fill((new Array(512)).fill(false))));
        this.last_colors_ = JSON.parse(JSON.stringify(new Array(256).fill('#000000')));
        this.last_selected_rectangle_area_ = null;
        /* compose */
        this.holder_ = document.createElement("div");
        this.holder_.appendChild(this.settings_holder_);
        this.holder_.appendChild(this.canvas_frame_);
        this.resize_cb_ = resize_cb;
        this.canvas_width_spin_.addEventListener("input", (event) => {
            const width = event.target.valueAsNumber;
            const height = this.canvas_height_spin_.valueAsNumber;
            if (!isNaN(width) && !isNaN(height)) {
                this.resize_cb_(width, height);
            }
        });
        this.canvas_height_spin_.addEventListener("input", (event) => {
            const height = event.target.valueAsNumber;
            const width = this.canvas_width_spin_.valueAsNumber;
            if (!isNaN(width) && !isNaN(height)) {
                this.resize_cb_(width, height);
            }
        });
    }
    static DrawLine(canvas_context, start_x, start_y, end_x, end_y) {
        canvas_context.moveTo(start_x, start_y);
        canvas_context.lineTo(end_x, end_y);
        return;
    }
    static CreateSmallGridIcon(icon_size) {
        const icon = document.createElement("canvas");
        icon.width = icon_size;
        icon.height = icon_size;
        const icon_context = icon.getContext("2d");
        icon_context.fillStyle = "#101010";
        icon_context.fillRect(0, 0, icon_size, icon_size);
        icon_context.beginPath();
        icon_context.lineWidth = 1;
        icon_context.strokeStyle = "#909090";
        for (let i = -0.5; i < icon_size; i += 4) {
            CanvasUi.DrawLine(icon_context, i, 0, i, icon_size);
            CanvasUi.DrawLine(icon_context, 0, i, icon_size, i);
        }
        icon_context.stroke();
        return icon;
    }
    static CreateLargeGridIcon(icon_size) {
        const icon = CanvasUi.CreateSmallGridIcon(icon_size);
        const icon_context = icon.getContext("2d");
        icon_context.beginPath();
        icon_context.lineWidth = 1;
        icon_context.strokeStyle = "#ffff00";
        for (let i = -0.5; i < icon_size; i += 8) {
            CanvasUi.DrawLine(icon_context, i, 0, i, icon_size);
            CanvasUi.DrawLine(icon_context, 0, i, icon_size, i);
        }
        icon_context.stroke();
        return icon;
    }
    get node() {
        return this.holder_;
    }
    get canvas() {
        return this.canvas_;
    }
    static PartiallyDrawGrid(canvas_context, w_grid_set, h_grid_set, width, height, scale, grid_color) {
        canvas_context.beginPath();
        const line_height = height;
        const line_width = width;
        const adjust_e = -(1 / scale) / 2;
        for (let w of w_grid_set) {
            const x = (w + 1) + adjust_e;
            CanvasUi.DrawLine(canvas_context, x, -0.5, x, line_height + 0.5);
        }
        for (let h of h_grid_set) {
            const y = (h + 1) + adjust_e;
            CanvasUi.DrawLine(canvas_context, -0.5, y, line_width + 0.5, y);
        }
        canvas_context.lineWidth = 1 / scale;
        canvas_context.strokeStyle = grid_color;
        canvas_context.stroke();
    }
    static DrawSmallGrid(canvas_context, width, height, scale, grid_color) {
        const all_w_grid_set = new Set();
        const all_h_grid_set = new Set();
        for (var w = 0; w < width; w++) {
            all_w_grid_set.add(w);
        }
        for (var h = 0; h < height; h++) {
            all_h_grid_set.add(h);
        }
        CanvasUi.PartiallyDrawGrid(canvas_context, all_w_grid_set, all_h_grid_set, width, height, scale, grid_color);
    }
    static DrawLargeGrid(canvas_context, width, height, scale, grid_color, grid_width, grid_height) {
        const all_w_grid_set = new Set();
        const all_h_grid_set = new Set();
        const large_grid_width = Math.min(512, Math.max(2, grid_width));
        const large_grid_height = Math.min(512, Math.max(2, grid_height));
        for (var w = large_grid_width; w <= width; w += large_grid_width) {
            all_w_grid_set.add(w - 1);
        }
        for (var h = large_grid_height; h <= height; h += large_grid_height) {
            all_h_grid_set.add(h - 1);
        }
        canvas_context.setLineDash([0.5, 0.5]);
        CanvasUi.PartiallyDrawGrid(canvas_context, all_w_grid_set, all_h_grid_set, width, height, scale, grid_color);
        canvas_context.setLineDash([]);
    }
    static PartiallyDrawColorIndex(canvas_context, pixels, target_pixel_set, width, height, scale, color) {
        const font_size = 8;
        canvas_context.save();
        canvas_context.textAlign = "center";
        canvas_context.textBaseline = "middle";
        canvas_context.font = `8px gothic`;
        canvas_context.fillStyle = color;
        canvas_context.scale(1 / scale, 1 / scale);
        const y_offset = font_size / 2;
        target_pixel_set.forEach((pixel_index) => {
            const w = Math.floor(pixel_index % width);
            const h = Math.floor(pixel_index / width);
            const dst_x = w * scale;
            const dst_y = h * scale;
            const ci = pixels[h][w];
            const x_offset = scale - String(ci).length * (font_size / 2 - 1) - 1;
            canvas_context.fillText(ci.toString(), dst_x + x_offset, dst_y + y_offset);
        });
        canvas_context.restore();
    }
    static DrawColorIndex(canvas_context, pixels, width, height, scale, color) {
        const target_pixel_set = new Set();
        for (var h = 0; h < height; h++) {
            for (var w = 0; w < width; w++) {
                target_pixel_set.add(h * width + w);
            }
        }
        CanvasUi.PartiallyDrawColorIndex(canvas_context, pixels, target_pixel_set, width, height, scale, color);
    }
    static DrawSelectedRectangleArea(canvas_context, rectangle, scale, frame_count) {
        const e_ = 0.5;
        canvas_context.setTransform(1, 0, 0, 1, 0, 0);
        const point_left = rectangle.left * scale + e_;
        const point_top = rectangle.top * scale + e_;
        const point_right = (rectangle.right + 1) * scale - e_;
        const point_bottom = (rectangle.bottom + 1) * scale - e_;
        canvas_context.setLineDash([4, 4]);
        canvas_context.lineWidth = 1;
        canvas_context.beginPath();
        canvas_context.strokeStyle = "#ffffff";
        canvas_context.lineDashOffset = frame_count % 8;
        CanvasUi.DrawLine(canvas_context, point_left, point_top, point_right, point_top);
        CanvasUi.DrawLine(canvas_context, point_right, point_top, point_right, point_bottom);
        CanvasUi.DrawLine(canvas_context, point_right, point_bottom, point_left, point_bottom);
        CanvasUi.DrawLine(canvas_context, point_left, point_bottom, point_left, point_top);
        canvas_context.stroke();
        canvas_context.beginPath();
        canvas_context.strokeStyle = "#000000";
        canvas_context.lineDashOffset = (frame_count + 4) % 8;
        CanvasUi.DrawLine(canvas_context, point_left, point_top, point_right, point_top);
        CanvasUi.DrawLine(canvas_context, point_right, point_top, point_right, point_bottom);
        CanvasUi.DrawLine(canvas_context, point_right, point_bottom, point_left, point_bottom);
        CanvasUi.DrawLine(canvas_context, point_left, point_bottom, point_left, point_top);
        canvas_context.stroke();
        canvas_context.setLineDash([]);
    }
    static ExtractTouchedPixelsAndGrids(current_pixels, last_pixels, current_pixel_mask, last_pixel_mask, width, height, current_colors, last_colors, last_selected_rectangle_area) {
        const pixel_index_set = new Set();
        const grid_w_set = new Set();
        const grid_h_set = new Set();
        /* ピクセル値の変化差分を抽出 */
        for (let h = 0; h < height; h++) {
            for (let w = 0; w < width; w++) {
                let is_touched = false;
                if (last_pixels[h][w] !== current_pixels[h][w]) {
                    is_touched = true;
                }
                else if (last_pixel_mask[h][w] !== current_pixel_mask[h][w]) {
                    is_touched = true;
                }
                else {
                    /* 色が変わっている場合も更新対象 */
                    const ci = last_pixels[h][w];
                    if (last_colors[ci] !== current_colors[ci]) {
                        is_touched = true;
                    }
                }
                if (is_touched) {
                    pixel_index_set.add(h * width + w);
                    grid_w_set.add(w);
                    grid_h_set.add(h);
                }
            }
        }
        /* 前回の矩形選択範囲の線を描画したピクセルは今回上書きが必要 */
        if (last_selected_rectangle_area !== null) {
            const rect = last_selected_rectangle_area;
            if (rect.top === rect.bottom) {
                for (let w = rect.left; w <= rect.right; w++) {
                    pixel_index_set.add(rect.top * width + w);
                }
            }
            else {
                for (let w = rect.left; w <= rect.right; w++) {
                    pixel_index_set.add(rect.top * width + w);
                    pixel_index_set.add(rect.bottom * width + w);
                }
            }
            const offset_top = rect.top + 1;
            const offset_bottom = rect.bottom - 1;
            if (0 <= (offset_bottom - offset_top)) {
                if (rect.left === rect.right) {
                    for (let h = offset_top; h <= offset_bottom; h++) {
                        pixel_index_set.add(h * width + rect.left);
                    }
                }
                else {
                    for (let h = offset_top; h <= offset_bottom; h++) {
                        pixel_index_set.add(h * width + rect.left);
                        pixel_index_set.add(h * width + rect.right);
                    }
                }
            }
            for (let h = rect.top; h <= rect.bottom; h++) {
                for (let w = rect.left; w <= rect.right; w++) {
                    grid_w_set.add(w);
                    grid_h_set.add(h);
                }
            }
        }
        return [pixel_index_set, grid_w_set, grid_h_set];
    }
    UpdateParameters(large_grid_width, large_grid_height, small_grid_color) {
        const scale = parseInt(this.scale_selector_.value);
        let width = parseInt(this.canvas_width_spin_.value);
        let height = parseInt(this.canvas_height_spin_.value);
        const small_grid_view = this.small_grid_view_.checked;
        const large_grid_view = this.large_grid_view_.checked;
        const color_index_view = this.color_index_view_.checked;
        if (isNaN(width)) {
            width = this.last_width_;
        }
        if (isNaN(height)) {
            height = this.last_height_;
        }
        if (this.canvas_.width !== width * scale) {
            this.canvas_.width = width * scale;
        }
        if (this.canvas_.height !== height * scale) {
            this.canvas_.height = height * scale;
        }
        const need_update_all = (this.last_scale_ !== scale)
            || (this.last_width_ !== width)
            || (this.last_height_ !== height)
            || (this.last_small_grid_view_ !== small_grid_view)
            || (this.last_large_grid_view_ !== large_grid_view)
            || (this.last_large_grid_width_ !== large_grid_width)
            || (this.last_large_grid_height_ !== large_grid_height)
            || (this.last_color_index_view_ !== color_index_view)
            || (this.last_small_grid_color_ !== small_grid_color);
        this.last_scale_ = scale;
        this.last_width_ = width;
        this.last_height_ = height;
        this.last_small_grid_view_ = small_grid_view;
        this.last_large_grid_view_ = large_grid_view;
        this.last_large_grid_width_ = large_grid_width;
        this.last_large_grid_height_ = large_grid_height;
        this.last_color_index_view_ = color_index_view;
        this.last_small_grid_color_ = small_grid_color;
        return need_update_all ? "need_all" : "partial";
    }
    Draw(pixels, pixels_mask, color_table, small_grid_color, large_grid_width, large_grid_height, large_grid_color, selected_rectangle_area, frame_count) {
        const draw_type = this.UpdateParameters(large_grid_width, large_grid_height, small_grid_color);
        const scale = this.last_scale_;
        const width = this.last_width_;
        const height = this.last_height_;
        const context = this.canvas_.getContext("2d");
        context.imageSmoothingEnabled = false;
        context.setTransform(1, 0, 0, 1, 0, 0);
        context.scale(scale, scale);
        if (draw_type === "need_all") {
            /* ピクセル描画 */
            for (let h = 0; h < height; h++) {
                for (let w = 0; w < width; w++) {
                    const color_index = pixels[h][w];
                    context.fillStyle = color_table[color_index];
                    context.fillRect(w, h, 1, 1);
                }
            }
            /* マスク表示 */
            context.fillStyle = '#ff0000';
            context.globalAlpha = 0.5;
            for (var h = 0; h < height; h++) {
                for (var w = 0; w < width; w++) {
                    if (pixels_mask[h][w]) {
                        context.fillRect(w, h, 1, 1);
                    }
                }
            }
            context.globalAlpha = 1;
            /* グリッド描画 */
            if (this.small_grid_view_.checked) {
                CanvasUi.DrawSmallGrid(context, width, height, scale, small_grid_color);
            }
            /* 色番号描画 */
            if (this.color_index_view_.checked) {
                CanvasUi.DrawColorIndex(context, pixels, width, height, scale, small_grid_color);
            }
            /* キャッシュ更新 */
            for (let h = 0; h < height; h++) {
                for (let w = 0; w < width; w++) {
                    this.last_pixels_[h][w] = pixels[h][w];
                    this.last_pixel_mask_[h][w] = pixels_mask[h][w];
                }
            }
            /* 色のキャッシュ更新 */
            for (let i = 0; i < 256; i++) {
                this.last_colors_[i] = color_table[i];
            }
        }
        else {
            /* 際描画が必要なピクセルとグリッドを抽出 */
            const [written_pixel_set, update_w_grid_set, update_h_grid_set] = CanvasUi.ExtractTouchedPixelsAndGrids(pixels, this.last_pixels_, pixels_mask, this.last_pixel_mask_, width, height, color_table, this.last_colors_, this.last_selected_rectangle_area_);
            /* ピクセルの部分描画 */
            written_pixel_set.forEach((pixel_index) => {
                const w = Math.floor(pixel_index % width);
                const h = Math.floor(pixel_index / width);
                const ci = pixels[h][w];
                const color = color_table[ci];
                context.fillStyle = color;
                context.fillRect(w, h, 1, 1);
            });
            /* マスクの部分表示 */
            context.fillStyle = '#ff0000';
            context.globalAlpha = 0.5;
            written_pixel_set.forEach((pixel_index) => {
                const w = Math.floor(pixel_index % width);
                const h = Math.floor(pixel_index / width);
                if (pixels_mask[h][w]) {
                    context.fillRect(w, h, 1, 1);
                }
            });
            context.globalAlpha = 1;
            /* グリッドの部分描画 */
            if (this.small_grid_view_.checked) {
                CanvasUi.PartiallyDrawGrid(context, update_w_grid_set, update_h_grid_set, width, height, scale, small_grid_color);
            }
            /* 色番号の部分描画 */
            if (this.color_index_view_.checked) {
                CanvasUi.PartiallyDrawColorIndex(context, pixels, written_pixel_set, width, height, scale, small_grid_color);
            }
        }
        if (this.large_grid_view_.checked) {
            CanvasUi.DrawLargeGrid(context, width, height, scale, large_grid_color, large_grid_width, large_grid_height);
        }
        if (selected_rectangle_area !== null) {
            CanvasUi.DrawSelectedRectangleArea(context, selected_rectangle_area, scale, frame_count);
        }
        /* キャッシュ更新 */
        /* ピクセルおよびマスク */
        for (let h = 0; h < height; h++) {
            for (let w = 0; w < width; w++) {
                this.last_pixels_[h][w] = pixels[h][w];
                this.last_pixel_mask_[h][w] = pixels_mask[h][w];
            }
        }
        /* 色　*/
        for (let i = 0; i < 256; i++) {
            this.last_colors_[i] = color_table[i];
        }
        /* 矩形選択 */
        this.last_selected_rectangle_area_ = selected_rectangle_area;
        return;
    }
    get canvas_width() {
        return this.last_width_;
    }
    get canvas_height() {
        return this.last_height_;
    }
    set canvas_width(new_width) {
        this.canvas_width_spin_.valueAsNumber = new_width;
    }
    set canvas_height(new_height) {
        this.canvas_height_spin_.valueAsNumber = new_height;
    }
    get edit_scale() {
        return this.last_scale_;
    }
    set edit_scale(new_scale) {
        const scales = [1, 2, 4, 8, 12, 16, 20, 24, 28, 32];
        const index = scales.indexOf(new_scale);
        if (0 <= index) {
            this.scale_selector_.selectedIndex = index;
        }
    }
}
CanvasUi.count_ = 0;


/***/ }),

/***/ "./built/gui/color_palette.js":
/*!************************************!*\
  !*** ./built/gui/color_palette.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ColorPaletteTableUi": () => (/* binding */ ColorPaletteTableUi)
/* harmony export */ });
class ColorPaletteTableUi {
    constructor(num_cols, cell_width, cell_height, initial_color_palette_index, preset_color_palettes, select_color_callback, dad_color_cell_callback, change_color_callback) {
        this.selected_index_ = 0;
        this.preset_color_palettes_ = preset_color_palettes;
        /* for color table UI */
        this.dummy_canvas_array_ = new Array(256);
        for (let i = 0; i < 256; i++) {
            const dummy_canvas = document.createElement("canvas");
            dummy_canvas.width = cell_width - 2;
            dummy_canvas.height = cell_height - 2;
            this.dummy_canvas_array_[i] = dummy_canvas;
        }
        this.color_cells_ = new Array(256);
        const initiali_color_palette = preset_color_palettes[initial_color_palette_index].colors;
        for (let i = 0; i < 256; i++) {
            const color_cell = document.createElement("td");
            color_cell.draggable = true;
            color_cell.style.backgroundColor = initiali_color_palette[i];
            color_cell.style.borderStyle = "solid";
            color_cell.style.borderWidth = "1px";
            color_cell.style.lineHeight = "1px";
            color_cell.appendChild(this.dummy_canvas_array_[i]);
            ColorPaletteTableUi.SetUnselectedColorCellStyle(color_cell);
            this.color_cells_[i] = color_cell;
        }
        ColorPaletteTableUi.SetSelectedColorCellStyle(this.color_cells_[this.selected_index_]);
        this.tr_array_ = new Array(16);
        for (let i = 0; i < 16; i++) {
            const tr = document.createElement("tr");
            for (let j = 0; j < 16; j++) {
                const td_index = 16 * i + j;
                tr.appendChild(this.color_cells_[td_index]);
            }
            this.tr_array_[i] = tr;
        }
        this.table_ = document.createElement("table");
        this.table_.style.borderSpacing = "0";
        for (let i = 0; i < 16; i++) {
            this.table_.appendChild(this.tr_array_[i]);
        }
        for (let i = 0; i < 256; i++) {
            this.color_cells_[i].addEventListener('click', () => {
                select_color_callback(i);
                ColorPaletteTableUi.SetUnselectedColorCellStyle(this.color_cells_[this.selected_index_]);
                ColorPaletteTableUi.SetSelectedColorCellStyle(this.color_cells_[i]);
                this.selected_index_ = i;
                this.UpdateColorEditView();
            });
            this.color_cells_[i].addEventListener('dragstart', (event) => {
                event.dataTransfer.setData("color_index", i.toString());
            });
            this.color_cells_[i].addEventListener('dragover', (event) => {
                event.preventDefault();
            });
            this.color_cells_[i].addEventListener('drop', (event) => {
                event.preventDefault();
                const drag_color_index = parseInt(event.dataTransfer.getData("color_index"));
                dad_color_cell_callback(drag_color_index, this.color_cells_[drag_color_index], i, this.color_cells_[i]);
                const tmp_color = this.color_cells_[drag_color_index].style.backgroundColor;
                this.color_cells_[drag_color_index].style.backgroundColor = this.color_cells_[i].style.backgroundColor;
                this.color_cells_[i].style.backgroundColor = tmp_color;
            });
        }
        /* for preset color palette UI */
        this.preset_palette_selector_ = document.createElement("select");
        const none_option = document.createElement("option");
        none_option.value = "0";
        none_option.innerText = "変更しない";
        this.preset_palette_selector_.append(none_option);
        for (let i = 0; i < preset_color_palettes.length; i++) {
            const preset_option = document.createElement("option");
            preset_option.value = (i + 1).toString();
            preset_option.innerText = preset_color_palettes[i].caption;
            this.preset_palette_selector_.append(preset_option);
        }
        this.preset_palette_selector_.selectedIndex = 0;
        this.reset_color_palette_button_ = document.createElement("button");
        this.reset_color_palette_button_.innerText = "リセット";
        this.reset_color_palette_button_.addEventListener('click', (event) => {
            const preset_command_index = parseInt(this.preset_palette_selector_.value);
            if (preset_command_index === 0) {
                return;
            }
            const preset_index = preset_command_index - 1;
            const preset_color_palette = this.preset_color_palettes_[preset_index].colors;
            for (let i = 0; i < 256; i++) {
                const color_cell = this.color_cells_[i];
                const color_string = preset_color_palette[i];
                color_cell.style.backgroundColor = color_string;
                change_color_callback(i, color_string);
            }
            this.UpdateColorEditView();
            this.preset_palette_selector_.value = "0";
        });
        /* for color edit UI */
        this.color_input_ = document.createElement("input");
        this.color_caption_ = document.createElement("div");
        this.color_caption_.style.float = "right";
        this.UpdateColorEditView();
        this.color_input_.type = "color";
        this.color_input_.addEventListener('input', (event) => {
            const i = this.selected_index_;
            const new_color_string = event.target.value;
            this.color_cells_[i].style.backgroundColor = new_color_string;
            this.UpdateColorEditCaption();
            change_color_callback(i, new_color_string);
        });
        this.preset_command_holder_ = document.createElement("div");
        this.color_table_holder_ = document.createElement("div");
        this.color_edit_holder_ = document.createElement("div");
        this.holder_ = document.createElement("div");
        this.preset_command_holder_.style.clear = "both";
        this.color_table_holder_.style.clear = "both";
        this.color_edit_holder_.style.clear = "both";
        this.holder_.style.clear = "both";
        this.holder_.style.width = "min-content";
        this.preset_command_holder_.appendChild(this.preset_palette_selector_);
        this.preset_command_holder_.appendChild(this.reset_color_palette_button_);
        this.color_table_holder_.appendChild(this.table_);
        this.color_edit_holder_.appendChild(this.color_input_);
        this.color_edit_holder_.appendChild(this.color_caption_);
        this.holder_.appendChild(this.preset_command_holder_);
        this.holder_.appendChild(this.color_table_holder_);
        this.holder_.appendChild(this.color_edit_holder_);
        return;
    }
    static SetUnselectedColorCellStyle(color_cell) {
        color_cell.style.borderColor = "#000000";
    }
    static SetSelectedColorCellStyle(color_cell) {
        color_cell.style.borderColor = "#00ff00";
    }
    static RgbStringToHexColor(rgb_string) {
        const [r_string, g_string, b_string] = rgb_string.split('(')[1].split(')')[0].split(',');
        const r_hex = ('00' + Number(r_string).toString(16)).slice(-2);
        const g_hex = ('00' + Number(g_string).toString(16)).slice(-2);
        const b_hex = ('00' + Number(b_string).toString(16)).slice(-2);
        return `#${r_hex}${g_hex}${b_hex}`;
    }
    UpdateColorEditCaption() {
        const i = this.selected_index_;
        const color = ColorPaletteTableUi.RgbStringToHexColor(this.color_cells_[i].style.backgroundColor);
        this.color_caption_.innerText = `${i}:${color}`;
    }
    UpdateColorEditView() {
        const i = this.selected_index_;
        const color = ColorPaletteTableUi.RgbStringToHexColor(this.color_cells_[i].style.backgroundColor);
        this.color_input_.value = color;
        this.color_caption_.innerText = `${i}:${color}`;
    }
    get node() {
        return this.holder_;
    }
    GetColor(index) {
        return this.color_cells_[index].style.backgroundColor;
    }
    GetColorTable() {
        const color_table = new Array(256);
        for (let i = 0; i < 256; i++) {
            color_table[i] = this.color_cells_[i].style.backgroundColor;
        }
        return color_table;
    }
    SetColor(index, color_string) {
        this.color_cells_[index].style.backgroundColor = color_string;
        if (this.selected_index_ === index) {
            this.UpdateColorEditView();
        }
    }
    SetColorTable(color_table) {
        for (let i = 0; i < 256; i++) {
            this.color_cells_[i].style.backgroundColor = color_table[i];
        }
        this.UpdateColorEditView();
    }
    SelectColorCell(color_index) {
        ColorPaletteTableUi.SetUnselectedColorCellStyle(this.color_cells_[this.selected_index_]);
        ColorPaletteTableUi.SetSelectedColorCellStyle(this.color_cells_[color_index]);
        this.selected_index_ = color_index;
        this.UpdateColorEditView();
    }
}


/***/ }),

/***/ "./built/gui/download_button.js":
/*!**************************************!*\
  !*** ./built/gui/download_button.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DonwloadButton": () => (/* binding */ DonwloadButton)
/* harmony export */ });
class DonwloadButton {
    constructor(parent, caption, dldata_request_callback) {
        this.link_ = document.createElement("a");
        this.button_ = document.createElement("button");
        this.link_.href = "#";
        this.button_.innerText = caption;
        this.button_.addEventListener('click', () => {
            const [dldata_filename, dldata_blob] = dldata_request_callback();
            const object_url = window.URL.createObjectURL(dldata_blob);
            this.link_.href = object_url;
            this.link_.download = dldata_filename;
        });
        this.link_.appendChild(this.button_);
        parent.appendChild(this.link_);
    }
}


/***/ }),

/***/ "./built/gui/layer.js":
/*!****************************!*\
  !*** ./built/gui/layer.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LayerUi": () => (/* binding */ LayerUi),
/* harmony export */   "LayerPaneUi": () => (/* binding */ LayerPaneUi)
/* harmony export */ });
/* harmony import */ var _dom_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom/dom */ "./built/dom/dom.js");

class LayerUi {
    constructor(parent, order, name, color, user_value) {
        this.parent_ = parent;
        this.user_value_ = user_value;
        this.layer_frame_ = document.createElement("div");
        this.layer_frame_.style.display = "flex";
        this.layer_frame_.style.alignItems = "center";
        this.tab_ = document.createElement("div");
        this.tab_.style.width = "40px";
        this.tab_.style.height = "32px";
        this.tab_.style.backgroundColor = color;
        this.tab_.style.display = "flex";
        this.tab_.style.justifyContent = "center";
        this.tab_.style.alignItems = "center";
        this.thumbnail_ = document.createElement("canvas");
        this.layer_lock_checkbox_ = document.createElement("input");
        this.layer_view_checkbox_ = document.createElement("input");
        this.layer_name_ = document.createElement("input");
        this.thumbnail_.width = 16;
        this.thumbnail_.height = 16;
        this.layer_lock_checkbox_.type = "checkbox";
        this.layer_lock_checkbox_.checked = false;
        this.layer_view_checkbox_.type = "checkbox";
        this.layer_view_checkbox_.checked = true;
        this.layer_name_.type = "text";
        this.layer_name_.value = name;
        this.layer_name_.style.height = '1em';
        this.layer_name_.style.paddingTop = (8).toString();
        this.layer_name_.style.paddingBottom = (8).toString();
        this.tab_.appendChild(this.thumbnail_);
        this.layer_frame_.appendChild(this.tab_);
        this.layer_frame_.appendChild(this.layer_lock_checkbox_);
        this.layer_frame_.appendChild(this.layer_view_checkbox_);
        this.layer_frame_.appendChild(this.layer_name_);
        this.order_ = order;
        this.layer_frame_.style.order = this.order_.toString();
        this.layer_frame_.tabIndex = 0;
        this.layer_frame_.style.backgroundColor = "rgb(255,255,255)";
        this.parent_.appendChild(this.layer_frame_);
    }
    Destruct() {
        this.parent_.removeChild(this.layer_frame_);
        return this.user_value_;
    }
    FocusIn() {
        this.layer_frame_.style.backgroundColor = 'rgb(0, 0, 255)';
        this.layer_frame_.style.boxShadow = "0px 0px 0px 0px";
        this.tab_.style.boxShadow = this.layer_frame_.style.boxShadow;
        this.Update(this.update_state_callback_, true, false);
    }
    FocusOut() {
        this.layer_frame_.style.backgroundColor = 'rgb(255, 255, 255)';
        this.layer_frame_.style.boxShadow = "0px 8px 16px -2px rgba(10,10,10,0.1), 2px 2px 3px 0px rgba(0,0,0,0.48) inset";
        this.tab_.style.boxShadow = this.layer_frame_.style.boxShadow;
        this.Update(this.update_state_callback_, false, true);
    }
    Update(callback, is_focusin, is_focusout) {
        callback(this.user_value_, this.order_, this.layer_name_.value, this.tab_.style.backgroundColor, this.layer_lock_checkbox_.checked, this.layer_view_checkbox_.checked, is_focusin, is_focusout, this.thumbnail_.getContext('2d'));
    }
    DrawThumbnail(callback) {
        callback(this.user_value_, this.order_, this.layer_lock_checkbox_.checked, this.layer_view_checkbox_.checked, this.thumbnail_.getContext('2d'));
    }
    AddFoucsinCallback(callback) {
        this.layer_frame_.addEventListener('focusin', (event) => {
            callback(this);
        });
    }
    AddUpdateStateCallback(callback) {
        this.layer_lock_checkbox_.addEventListener('change', (event) => {
            this.Update(callback, false, false);
        });
        this.layer_view_checkbox_.addEventListener('change', (event) => {
            this.Update(callback, false, false);
        });
        this.layer_name_.addEventListener('change', (event) => {
            this.Update(callback, false, false);
        });
        this.update_state_callback_ = callback;
    }
    get order() {
        return this.order_;
    }
    set order(new_order) {
        if (new_order < 0) {
            return;
        }
        this.order_ = new_order;
        this.layer_frame_.style.order = this.order_.toString();
        this.Update(this.update_state_callback_, false, false);
    }
}
class LayerPaneUi {
    constructor(register_callback, destructed_callback, swap_callback, updated_state_callback, draw_thumbnail_callback, pre_event_callback) {
        this.layers_ = new Array(0);
        this.frame_ = document.createElement("div");
        this.command_holder_ = document.createElement("div");
        this.layer_holder_ = document.createElement("div");
        this.current_layer_ = null;
        this.command_holder_.style.display = "flex";
        this.command_holder_.style.backgroundColor = "rgb(95, 95, 95)";
        this.layer_holder_.style.display = "flex";
        this.layer_holder_.style.flexDirection = "column-reverse";
        this.layer_holder_.style.backgroundColor = "rgb(127, 127, 127)";
        this.new_layer_button_ = _dom_dom__WEBPACK_IMPORTED_MODULE_0__.Dom.CreateButton("＋", (buttonElement) => {
            this.pre_event_callback_("register");
            const registration_order = this.CalculateRegistrationOrder(this.current_layer_.order);
            const [layer_name, color, user_value] = this.register_callback_(registration_order);
            this.CreateNewLayer(this.current_layer_.order, layer_name, color, user_value);
        });
        this.up_layer_button_ = _dom_dom__WEBPACK_IMPORTED_MODULE_0__.Dom.CreateButton("▲", (buttonElement) => {
            this.UpLayer(this.current_layer_.order);
        });
        this.down_layer_button_ = _dom_dom__WEBPACK_IMPORTED_MODULE_0__.Dom.CreateButton("▼", (buttonElement) => {
            this.DownLayer(this.current_layer_.order);
        });
        this.delete_layer_button_ = _dom_dom__WEBPACK_IMPORTED_MODULE_0__.Dom.CreateButton("×", (buttonElement) => {
            if (1 < this.layers_.length) {
                this.pre_event_callback_("remove");
                this.DeleteCurrentLayer();
            }
        });
        {
            const button_size = `2em`;
            this.new_layer_button_.style.width = button_size;
            this.new_layer_button_.style.height = button_size;
            this.up_layer_button_.style.width = button_size;
            this.up_layer_button_.style.height = button_size;
            this.down_layer_button_.style.width = button_size;
            this.down_layer_button_.style.height = button_size;
            this.delete_layer_button_.style.width = button_size;
            this.delete_layer_button_.style.height = button_size;
        }
        this.register_callback_ = register_callback;
        this.removed_callback_ = destructed_callback;
        this.swap_callback_ = swap_callback;
        this.updated_state_callback_ = updated_state_callback;
        this.draw_thumbnail_callback_ = draw_thumbnail_callback;
        this.pre_event_callback_ = pre_event_callback;
        this.command_holder_.appendChild(this.new_layer_button_);
        this.command_holder_.appendChild(this.up_layer_button_);
        this.command_holder_.appendChild(this.down_layer_button_);
        this.command_holder_.appendChild(this.delete_layer_button_);
        this.frame_.appendChild(this.command_holder_);
        this.frame_.appendChild(this.layer_holder_);
        return;
    }
    ChangeFocus(focus_in_layer) {
        if (focus_in_layer === this.current_layer_) {
            return;
        }
        focus_in_layer.FocusIn();
        if (this.current_layer_ !== null) {
            this.current_layer_.FocusOut();
        }
        this.current_layer_ = focus_in_layer;
        return;
    }
    IsLayerSwapable(lh_order, rh_order) {
        let lh_layer = null;
        let rh_layer = null;
        for (let layer of this.layers_) {
            if (layer.order === lh_order) {
                lh_layer = layer;
            }
            if (layer.order === rh_order) {
                rh_layer = layer;
            }
            if ((lh_layer !== null) && (rh_layer !== null)) {
                break;
            }
        }
        if (lh_layer === null) {
            return false;
        }
        if (rh_layer === null) {
            return false;
        }
        return true;
    }
    SwapLayer(lh_order, rh_order) {
        let lh_layer = null;
        let rh_layer = null;
        for (let layer of this.layers_) {
            if (layer.order === lh_order) {
                lh_layer = layer;
            }
            if (layer.order === rh_order) {
                rh_layer = layer;
            }
            if ((lh_layer !== null) && (rh_layer !== null)) {
                break;
            }
        }
        if (lh_layer === null) {
            return false;
        }
        if (rh_layer === null) {
            return false;
        }
        const tmp_order = lh_layer.order;
        lh_layer.order = rh_layer.order;
        rh_layer.order = tmp_order;
        return true;
    }
    CalculateRegistrationOrder(insert_target_order) {
        if (this.layers_.length === 0) {
            return 0;
        }
        return Math.min(insert_target_order, this.layers_.length - 1) + 1;
    }
    CreateNewLayer(insert_target_order, layer_name, color, user_value) {
        const registration_order = this.CalculateRegistrationOrder(insert_target_order);
        if (0 < registration_order) {
            for (let layer of this.layers_) {
                if (registration_order <= layer.order) {
                    layer.order++;
                }
            }
            insert_target_order += 1;
        }
        const new_layer = new LayerUi(this.layer_holder_, insert_target_order, layer_name, color, user_value);
        new_layer.AddFoucsinCallback((focus_in_layer) => { this.ChangeFocus(focus_in_layer); });
        new_layer.AddUpdateStateCallback(this.updated_state_callback_);
        this.layers_.push(new_layer);
        this.ChangeFocus(new_layer);
        return;
    }
    DeleteCurrentLayer() {
        if (this.current_layer_ === null) {
            return;
        }
        if (this.layers_.length === 1) {
            const destructed_order = this.current_layer_.order;
            const user_value = this.current_layer_.Destruct();
            this.removed_callback_(user_value, destructed_order);
            this.current_layer_ = null;
            this.layers_.splice(0, 1);
            return;
        }
        let target_index;
        for (target_index = 0; target_index < this.layers_.length; target_index++) {
            if (this.layers_[target_index] === this.current_layer_) {
                break;
            }
        }
        this.layers_.splice(target_index, 1);
        const current_order = Math.min(this.current_layer_.order, this.layers_.length - 1);
        for (let layer of this.layers_) {
            if (current_order < layer.order) {
                layer.order--;
            }
            if (current_order === layer.order) {
                const destructed_order = this.current_layer_.order;
                const user_value = this.current_layer_.Destruct();
                this.removed_callback_(user_value, destructed_order);
                this.current_layer_ = layer;
            }
        }
        this.current_layer_.FocusIn();
        return;
    }
    DeleteAll() {
        const num_layers = this.layers_.length;
        for (let i = 0; i < num_layers; i++) {
            this.DeleteCurrentLayer();
        }
    }
    CreateNewLayers(creation_parameters) {
        const ordered_parameters = Array(creation_parameters.length);
        for (let parameter of creation_parameters) {
            ordered_parameters[parameter[0]] = parameter;
        }
        for (let parameter of ordered_parameters) {
            parameter[0] = Math.max(0, parameter[0] - 1);
            this.CreateNewLayer(...parameter);
        }
    }
    CreateBrandNewLayers(creation_parameters) {
        this.DeleteAll();
        const ordered_parameters = Array(creation_parameters.length);
        for (let parameter of creation_parameters) {
            ordered_parameters[parameter[0]] = parameter;
        }
        for (let parameter of ordered_parameters) {
            parameter[0] = Math.max(0, parameter[0] - 1);
            this.CreateNewLayer(...parameter);
        }
        for (const layer of this.layers_.values()) {
            layer.FocusOut();
        }
        this.current_layer_ = this.layers_[0];
        this.current_layer_.FocusIn();
    }
    UpLayer(target_order) {
        if (this.IsLayerSwapable(target_order, target_order + 1)) {
            this.pre_event_callback_("swap");
        }
        if (this.SwapLayer(target_order, target_order + 1)) {
            this.swap_callback_(target_order, target_order + 1);
        }
        return;
    }
    DownLayer(target_order) {
        if (this.IsLayerSwapable(target_order, target_order - 1)) {
            this.pre_event_callback_("swap");
        }
        if (this.SwapLayer(target_order, target_order - 1)) {
            this.swap_callback_(target_order, target_order - 1);
        }
        return;
    }
    Draw() {
        for (let layer of this.layers_) {
            layer.DrawThumbnail(this.draw_thumbnail_callback_);
        }
    }
    get node() {
        return this.frame_;
    }
}


/***/ }),

/***/ "./built/gui/preview_window.js":
/*!*************************************!*\
  !*** ./built/gui/preview_window.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PreviewWindowUi": () => (/* binding */ PreviewWindowUi)
/* harmony export */ });
/* harmony import */ var _dom_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom/dom */ "./built/dom/dom.js");

class PreviewWindowUi {
    constructor(width, height) {
        this.canvas_ = document.createElement("canvas");
        this.canvas_.width = width;
        this.canvas_.height = height;
        this.canvas_.style.margin = "auto";
        this.canvas_frame_ = document.createElement("div");
        this.canvas_frame_.style.display = "flex";
        this.canvas_frame_.appendChild(this.canvas_);
        this.scale_selector_ = _dom_dom__WEBPACK_IMPORTED_MODULE_0__.Dom.CreateSelector([1, 2, 3, 4, 6, 8, 12, 16, 24], (index, item) => { return `x${item}`; }, 0);
        this.command_frame_ = document.createElement("div");
        this.command_frame_.style.textAlign = "right";
        this.command_frame_.innerText = "表示倍率";
        this.command_frame_.appendChild(this.scale_selector_);
        this.holder_ = document.createElement("div");
        this.holder_.appendChild(this.command_frame_);
        this.holder_.appendChild(this.canvas_frame_);
    }
    get node() {
        return this.holder_;
    }
    Draw(pixels, color_table, width, height) {
        const view_scale = parseInt(this.scale_selector_.value);
        if (this.canvas_.width !== width * view_scale) {
            this.canvas_.width = width * view_scale;
        }
        if (this.canvas_.height !== height * view_scale) {
            this.canvas_.height = height * view_scale;
        }
        const context = this.canvas_.getContext("2d");
        context.imageSmoothingEnabled = false;
        context.setTransform(1, 0, 0, 1, 0, 0);
        context.scale(view_scale, view_scale);
        for (let h = 0; h < height; h++) {
            for (let w = 0; w < width; w++) {
                const color_index = pixels[h][w];
                context.fillStyle = color_table[color_index];
                context.fillRect(w, h, 1, 1);
            }
        }
    }
}


/***/ }),

/***/ "./built/gui/sprite_animation_preview_window.js":
/*!******************************************************!*\
  !*** ./built/gui/sprite_animation_preview_window.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SpriteAnimationPreviewWindowUi": () => (/* binding */ SpriteAnimationPreviewWindowUi)
/* harmony export */ });
/* harmony import */ var _dom_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom/dom */ "./built/dom/dom.js");

const CreateRightBox = function () {
    const div = document.createElement("div");
    div.style.float = "right";
    return div;
};
class SpriteAnimationPreviewWindowUi {
    constructor(width, height) {
        this.sprite_width_ = _dom_dom__WEBPACK_IMPORTED_MODULE_0__.Dom.CreateNumberInput(1, 512, width);
        this.sprite_height_ = _dom_dom__WEBPACK_IMPORTED_MODULE_0__.Dom.CreateNumberInput(1, 512, height);
        this.scale_selector_ = _dom_dom__WEBPACK_IMPORTED_MODULE_0__.Dom.CreateSelector([1, 2, 3, 4, 6, 8, 12, 16, 24], (index, item) => { return `x${item}`; }, 0);
        this.scale_selector_holder_ = CreateRightBox();
        this.scale_selector_holder_.appendChild(_dom_dom__WEBPACK_IMPORTED_MODULE_0__.Dom.CreateText("表示倍率"));
        this.scale_selector_holder_.appendChild(this.scale_selector_);
        this.size_frame_ = document.createElement("div");
        this.size_frame_.appendChild(_dom_dom__WEBPACK_IMPORTED_MODULE_0__.Dom.CreateText("サイズ"));
        this.size_frame_.appendChild(this.sprite_width_);
        this.size_frame_.appendChild(_dom_dom__WEBPACK_IMPORTED_MODULE_0__.Dom.CreateText("x"));
        this.size_frame_.appendChild(this.sprite_height_);
        this.size_frame_.appendChild(this.scale_selector_holder_);
        this.animation_step_par_frame_ = _dom_dom__WEBPACK_IMPORTED_MODULE_0__.Dom.CreateNumberInput(1, 1000, 1);
        this.is_playing_ = false;
        this.animation_playback_button_ = _dom_dom__WEBPACK_IMPORTED_MODULE_0__.Dom.CreateButton("▶︎", (buttonElement) => {
            buttonElement.innerText = this.is_playing_ === true ? "▶︎" : "■";
            this.is_playing_ = !this.is_playing_;
        });
        this.command_frame_ = document.createElement("div");
        this.command_frame_.appendChild(this.animation_step_par_frame_);
        this.command_frame_.appendChild(_dom_dom__WEBPACK_IMPORTED_MODULE_0__.Dom.CreateText("/１コマ"));
        this.command_frame_.appendChild(this.animation_playback_button_);
        this.canvas_ = document.createElement("canvas");
        this.canvas_.width = width;
        this.canvas_.height = height;
        this.canvas_.style.margin = "auto";
        this.canvas_frame_ = document.createElement("div");
        this.canvas_frame_.style.display = "flex";
        this.canvas_frame_.appendChild(this.canvas_);
        this.sprite_animation_indices_ = new Array(0);
        this.sprite_indices_ = document.createElement("textarea");
        this.sprite_indices_.style.height = "1.4em";
        this.sprite_indices_.innerText = "0";
        this.settings_frame_ = document.createElement("div");
        this.settings_frame_.appendChild(this.sprite_indices_);
        this.holder_ = document.createElement("div");
        this.holder_.appendChild(this.size_frame_);
        this.holder_.appendChild(this.command_frame_);
        this.holder_.appendChild(this.canvas_frame_);
        this.holder_.appendChild(this.settings_frame_);
    }
    UpdateSpriteIndicesArray() {
        const index_strings = this.sprite_indices_.value.split(',');
        this.sprite_animation_indices_.length = 0;
        for (let index_string of index_strings) {
            const parsed = parseInt(index_string);
            if (!isNaN(parsed)) {
                this.sprite_animation_indices_.push(parsed);
            }
        }
    }
    get node() {
        return this.holder_;
    }
    Draw(pixels, color_table, width, height, frame_count) {
        if (!this.is_playing_) {
            return;
        }
        this.UpdateSpriteIndicesArray();
        const num_indeices = this.sprite_animation_indices_.length;
        if (0 === num_indeices) {
            return;
        }
        const step_par_frame = Math.max(1, this.animation_step_par_frame_.valueAsNumber);
        const frame_number = Math.floor(frame_count / step_par_frame) % num_indeices;
        const sprite_index = this.sprite_animation_indices_[frame_number];
        const sprite_w = Math.max(1, Math.min(width, this.sprite_width_.valueAsNumber));
        const sprite_h = Math.max(1, Math.min(height, this.sprite_height_.valueAsNumber));
        const sprite_count_in_w = Math.floor(width / sprite_w);
        const sprite_count_in_h = Math.floor(height / sprite_h);
        const max_sprite_index = sprite_count_in_w * sprite_count_in_h;
        if (max_sprite_index <= sprite_index) {
            return;
        }
        const pixel_w_offset = Math.floor(sprite_index % sprite_count_in_w) * sprite_w;
        const pixel_h_offset = Math.floor(sprite_index / sprite_count_in_w) * sprite_h;
        const max_w = Math.min(pixel_w_offset + sprite_w, width);
        const max_h = Math.min(pixel_h_offset + sprite_h, height);
        const view_scale = parseInt(this.scale_selector_.value);
        if (this.canvas_.width !== sprite_w * view_scale) {
            this.canvas_.width = sprite_w * view_scale;
        }
        if (this.canvas_.height !== sprite_h * view_scale) {
            this.canvas_.height = sprite_h * view_scale;
        }
        const context = this.canvas_.getContext('2d');
        context.imageSmoothingEnabled = false;
        context.setTransform(1, 0, 0, 1, 0, 0);
        context.scale(view_scale, view_scale);
        for (let h = pixel_h_offset; h < max_h; h++) {
            for (let w = pixel_w_offset; w < max_w; w++) {
                const color_index = pixels[h][w];
                context.fillStyle = color_table[color_index];
                context.fillRect(w - pixel_w_offset, h - pixel_h_offset, 1, 1);
            }
        }
        return;
    }
}


/***/ }),

/***/ "./built/gui/tab_pane.js":
/*!*******************************!*\
  !*** ./built/gui/tab_pane.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TabPaneUi": () => (/* binding */ TabPaneUi)
/* harmony export */ });
class TabPaneUi {
    constructor() {
        if (TabPaneUi.tab_content_class_style_ === null) {
            const style = document.createElement("style");
            style.innerText
                = `.tab_content {`
                    + `display: none;`
                    + `clear: both;`
                    + `overflow: scroll;`
                    + `resize: both;`
                    + `}`
                    + `input[name="tab_tags"] {`
                    + `display: none;`
                    + `}`
                    + `.tab_tag {`
                    + `text-align: center;`
                    + `display: block;`
                    + `float: left;`
                    + `order: -1;`
                    + `margin: 2px 2px 0px;`
                    + `}`
                    + `input:checked + .tab_tag + .tab_content {`
                    + `display: block;`
                    + `}`;
            document.getElementsByTagName("head").item(0).appendChild(style);
            TabPaneUi.tab_content_class_style_ = style;
        }
        this.tab_frame_ = document.createElement("div");
        this.tab_frame_.style.display = "grid";
        //this.tab_frame_.style.gridAutoColumns = "max-content";
        this.tab_frame_.style.gridAutoColumns = "1fr";
        this.tab_frame_.style.gridAutoRows = "max-content";
        this.tab_frame_.style.gridTemplateAreas = `"t0" "c"`;
        this.current_tab_ = null;
        this.local_tab_count_ = 0;
    }
    FitSize() {
        if (!("width" in this.current_tab_.style)) {
            return;
        }
        const contents = this.tab_frame_.getElementsByClassName("tab_content");
        const length = contents.length;
        for (let i = 0; i < length; i++) {
            contents[i].style.width = this.current_tab_.style.width;
            contents[i].style.height = this.current_tab_.style.height;
        }
        return;
    }
    AddTab(content, tab_title) {
        const tag_id = `tab_${TabPaneUi.global_tab_count_}_tag`;
        const tab_radio = document.createElement("input");
        tab_radio.type = "radio";
        tab_radio.id = tag_id;
        tab_radio.name = "tab_tags";
        const tab_label = document.createElement("label");
        tab_label.htmlFor = tag_id;
        tab_label.innerText = tab_title;
        tab_label.className = "tab_tag";
        tab_label.style.backgroundColor = content.style.backgroundColor;
        tab_label.style.gridArea = `t${this.local_tab_count_}`;
        const content_frame = document.createElement("div");
        content_frame.appendChild(content);
        content_frame.className = "tab_content";
        content_frame.style.backgroundColor = content.style.backgroundColor;
        content_frame.style.order = "1";
        content_frame.style.gridArea = "c";
        if (this.tab_frame_.childElementCount === 0) {
            tab_radio.checked = true;
            this.current_tab_ = content_frame;
        }
        tab_radio.addEventListener("change", (event) => {
            this.FitSize();
            this.current_tab_ = content_frame;
        });
        this.local_tab_count_++;
        const tag_grids = new Array(this.local_tab_count_);
        const content_grids = new Array(this.local_tab_count_);
        for (let i = 0; i < this.local_tab_count_; i++) {
            tag_grids[i] = `t${i}`;
            content_grids[i] = "c";
        }
        this.tab_frame_.style.gridTemplateAreas = `"${tag_grids.join(" ")}" "${content_grids.join(" ")}"`;
        this.tab_frame_.appendChild(tab_radio);
        this.tab_frame_.appendChild(tab_label);
        this.tab_frame_.appendChild(content_frame);
        TabPaneUi.global_tab_count_++;
        return;
    }
    get node() {
        return this.tab_frame_;
    }
}
TabPaneUi.tab_content_class_style_ = null;
TabPaneUi.global_tab_count_ = 0;


/***/ }),

/***/ "./built/gui/toolbox.js":
/*!******************************!*\
  !*** ./built/gui/toolbox.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ToolBoxUi": () => (/* binding */ ToolBoxUi)
/* harmony export */ });
function CreatePanel(name, title, base64icon, size) {
    const tool_id = `tool_panel_${name}`;
    const input_radio = document.createElement("input");
    input_radio.type = "radio";
    input_radio.id = tool_id;
    input_radio.name = "tool panels";
    input_radio.style.display = `none`;
    const input_label = document.createElement("label");
    input_label.htmlFor = tool_id;
    input_label.style.margin = `0px`;
    input_label.style.padding = `0px`;
    input_label.style.alignContent = `center`;
    input_label.style.lineHeight = `1px`;
    const icon = document.createElement("img");
    icon.width = size;
    icon.height = size;
    icon.style.imageRendering = `crisp-edges`;
    icon.src = base64icon;
    icon.title = title;
    icon.style.outlineOffset = '-2px';
    input_label.appendChild(icon);
    return [input_radio, input_label, icon];
}
class ToolBoxUi {
    constructor(tool_list, SelectCallback) {
        this.holder_ = document.createElement("div");
        for (let i = 0; i < tool_list.length; i++) {
            const [input_radio, input_label, icon] = CreatePanel(tool_list[i].kind, tool_list[i].title, tool_list[i].base64icon, 32);
            if (i == 0) {
                icon.style.outline = ToolBoxUi.outline_style_;
                this.current_icon_ = icon;
                this.current_kind_ = tool_list[0].kind;
            }
            input_radio.addEventListener("change", (event) => {
                SelectCallback(this.current_kind_, tool_list[i].kind);
                this.current_icon_.style.outline = 'none';
                icon.style.outline = ToolBoxUi.outline_style_;
                this.current_icon_ = icon;
                this.current_kind_ = tool_list[i].kind;
            });
            this.holder_.appendChild(input_radio);
            this.holder_.appendChild(input_label);
        }
    }
    get node() {
        return this.holder_;
    }
}
ToolBoxUi.outline_style_ = `2px solid rgb(255,0,0)`;


/***/ }),

/***/ "./built/misc.js":
/*!***********************!*\
  !*** ./built/misc.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Misc": () => (/* binding */ Misc)
/* harmony export */ });
var Misc;
(function (Misc) {
    function Make2dArray(width, height, initial_value) {
        return JSON.parse(JSON.stringify((new Array(height)).fill((new Array(width)).fill(initial_value))));
    }
    Misc.Make2dArray = Make2dArray;
    function GenerateArray(num_elements, CreateElementsCallback) {
        const new_array = new Array(num_elements);
        for (let i = 0; i < num_elements; i++) {
            new_array[i] = CreateElementsCallback(i);
        }
        return new_array;
    }
    Misc.GenerateArray = GenerateArray;
    function LineTo2d(x0, y0, x1, y1, PixelOnLineCallback) {
        const dx = (x0 < x1) ? x1 - x0 : x0 - x1;
        const dy = (y0 < y1) ? y1 - y0 : y0 - y1;
        const sx = (x0 < x1) ? 1 : -1;
        const sy = (y0 < y1) ? 1 : -1;
        let e1 = dx - dy;
        for (;;) {
            PixelOnLineCallback(x0, y0);
            if ((x0 === x1) && (y0 === y1)) {
                break;
            }
            const e2 = e1 * 2;
            if (-dy < e2) {
                e1 -= dy;
                x0 += sx;
            }
            if (e2 < dx) {
                e1 += dx;
                y0 += sy;
            }
        }
    }
    Misc.LineTo2d = LineTo2d;
    ;
    function RgbToHexColor(r, g, b) {
        const r_hex = ('00' + r.toString(16)).slice(-2);
        const g_hex = ('00' + g.toString(16)).slice(-2);
        const b_hex = ('00' + b.toString(16)).slice(-2);
        return `#${r_hex}${g_hex}${b_hex}`;
    }
    Misc.RgbToHexColor = RgbToHexColor;
    function RgbStringToHexColor(rgb_string) {
        const [r_string, g_string, b_string] = rgb_string.split('(')[1].split(')')[0].split(',');
        const r_hex = ('00' + Number(r_string).toString(16)).slice(-2);
        const g_hex = ('00' + Number(g_string).toString(16)).slice(-2);
        const b_hex = ('00' + Number(b_string).toString(16)).slice(-2);
        return `#${r_hex}${g_hex}${b_hex}`;
    }
    Misc.RgbStringToHexColor = RgbStringToHexColor;
    function ExtractBaseName(filepath) {
        const path_delimiter = /\\/g;
        const path_tokens = filepath.slice(0).replace(path_delimiter, '/').split('/');
        const filename = (2 <= path_tokens.length) ? path_tokens[path_tokens.length - 1] : path_tokens[0];
        const name_tokens = filename.split('.');
        const basename = (2 <= name_tokens.length) ? name_tokens.splice(0, name_tokens.length - 1).join('.') : name_tokens[0];
        return basename;
    }
    Misc.ExtractBaseName = ExtractBaseName;
    function MakeWebSafeColorList() {
        const gray_colors = Array(0); /* 利便性のためにグレースケールだけ別で並べる */
        const other_colors = Array(0);
        const blank_colors = Array(256 - (6 * 6 * 6)).fill('#000000');
        const c = ['00', '33', '66', '99', 'cc', 'ff'];
        for (let b = 0; b < 6; b++) {
            for (let g = 0; g < 6; g++) {
                for (let r = 0; r < 6; r++) {
                    const color = `#${c[r]}${c[g]}${c[b]}`;
                    if (r === g && r === b) {
                        gray_colors.push(color);
                    }
                    else {
                        other_colors.push(color);
                    }
                }
            }
        }
        return gray_colors.concat(other_colors).concat(blank_colors);
    }
    Misc.MakeWebSafeColorList = MakeWebSafeColorList;
    function HsvToRgb(H, S, V) {
        /* 0 <= h < 360 */
        const F = V * (1 - S); /* floor */
        const C = V; /* ceil */
        const area_index = Number(Math.floor(H / 60));
        const coef = (area_index % 2) === 0 ? (H % 60) / 60 : 1 - (H % 60) / 60;
        const X = coef * (C - F) + F;
        let r = 0;
        let g = 0;
        let b = 0;
        switch (area_index) {
            case 0:
                [r, g, b] = [C, X, F];
                break;
            case 1:
                [r, g, b] = [X, C, F];
                break;
            case 2:
                [r, g, b] = [F, C, X];
                break;
            case 3:
                [r, g, b] = [F, X, C];
                break;
            case 4:
                [r, g, b] = [X, F, C];
                break;
            case 5:
                [r, g, b] = [C, F, X];
                break;
        }
        return [Math.floor(r * 255), Math.floor(g * 255), Math.floor(b * 255)];
    }
    Misc.HsvToRgb = HsvToRgb;
    function MakeHSVBalancedColorList(s_divide) {
        const colors = new Array(256);
        const num_colors = 16;
        let i = 0;
        /* gray scale */
        const grayscale_max_v = Math.floor(256 / num_colors);
        for (let v = 0; v < grayscale_max_v; v++) {
            let [r, g, b] = HsvToRgb(0, 0, v / (grayscale_max_v - 1));
            colors[i] = this.RgbToHexColor(r, g, b);
            i++;
        }
        const h_step = Math.floor(360 / (num_colors - 1));
        const num_s = s_divide;
        const num_v = Math.floor(256 / (s_divide * num_colors));
        const max_s = num_s + 1;
        const max_v = num_v + 1;
        for (let h = 0; h < 360; h += h_step) {
            for (let s = 1; s < max_s; s++) {
                for (let v = 1; v < max_v; v++) {
                    let [r, g, b] = HsvToRgb(h, s / num_s, v / num_v);
                    colors[i] = this.RgbToHexColor(r, g, b);
                    i++;
                }
            }
        }
        return colors;
    }
    Misc.MakeHSVBalancedColorList = MakeHSVBalancedColorList;
})(Misc || (Misc = {}));


/***/ }),

/***/ "./built/resources.js":
/*!****************************!*\
  !*** ./built/resources.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Resources": () => (/* binding */ Resources)
/* harmony export */ });
var Resources;
(function (Resources) {
    Resources.tool_icon_pen = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAIBAMAAAA2IaO4AAAAD1BMVEUAAAC2trbnsJFFYFN8m4OF5U+bAAAAKklEQVR42mMQFBRkZhAUFDABEszODIICKgZAgokRSDAIMjAwCgoCJQQFATB6AjfliEb8AAAAAElFTkSuQmCC";
    Resources.tool_icon_select = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAIAQMAAAD+wSzIAAAABlBMVEUAAAC2trb0KSTqAAAAFUlEQVR42mNQZfjLUM9QCyY9Gf4DACQuBOOudRsBAAAAAElFTkSuQmCC";
    Resources.tool_icon_fill = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAIAgMAAAC5YVYYAAAADFBMVEUAAABLZeq2trb///89RsdCAAAAIUlEQVR42mNYZc+w4j/DClGGZa0MyxYyLFvBsGwVQ2goAG87CQjKFv9LAAAAAElFTkSuQmCC";
})(Resources || (Resources = {}));


/***/ }),

/***/ "./built/rgb_color_palette.js":
/*!************************************!*\
  !*** ./built/rgb_color_palette.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RgbColor": () => (/* binding */ RgbColor),
/* harmony export */   "RgbColorPalette": () => (/* binding */ RgbColorPalette)
/* harmony export */ });
class RgbColor {
    constructor(r = 0, g = 0, b = 0) {
        this.r = r;
        this.g = g;
        this.b = b;
    }
    ToHexColor() {
        const r_hex = ('00' + this.r.toString(16)).slice(-2);
        const g_hex = ('00' + this.g.toString(16)).slice(-2);
        const b_hex = ('00' + this.b.toString(16)).slice(-2);
        return `#${r_hex}${g_hex}${b_hex}`;
    }
    ToRgbString() {
        return `rgb(${this.r},${this.g},${this.b})`;
    }
    SetHexColor(hex_color) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex_color);
        if (result) {
            this.r = parseInt(result[1], 16);
            this.g = parseInt(result[2], 16);
            this.b = parseInt(result[3], 16);
        }
        return !!(result);
    }
    SetRgbString(rgb_string) {
        const result = /^rgb\s*\(\s*([\d]+)\s*,\s*([\d]+)\s*,\s*([\d]+)\s*\)/i.exec(rgb_string);
        if (result) {
            this.r = Number(result[1]);
            this.g = Number(result[2]);
            this.b = Number(result[3]);
        }
        return !!(result);
    }
    SetColorString(color_string) {
        return this.SetHexColor(color_string) ? true : this.SetRgbString(color_string);
    }
}
class RgbColorPalette {
    constructor() {
        this.colors_ = new Array(256);
        for (let i = 0; i < 256; i++) {
            this.colors_[i] = new RgbColor();
        }
    }
    SetPresetColor(index, preset_color) {
        if (preset_color == "black") {
            this.colors_[index].r = 0;
            this.colors_[index].g = 0;
            this.colors_[index].b = 0;
        }
    }
    SetColor(index, color) {
        this.colors_[index].r = color.r;
        this.colors_[index].g = color.g;
        this.colors_[index].b = color.b;
    }
    SetColorByString(index, color) {
        this.colors_[index].SetRgbString(color);
    }
    GetColor(index) {
        return this.colors_[index];
    }
    SwapColor(index_a, index_b) {
        const tmp_color = this.colors_[index_a];
        this.colors_[index_a] = this.colors_[index_b];
        this.colors_[index_b] = tmp_color;
    }
}


/***/ }),

/***/ "./built/windows_bitmap.js":
/*!*********************************!*\
  !*** ./built/windows_bitmap.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WindowsIndexColorBitmap": () => (/* binding */ WindowsIndexColorBitmap)
/* harmony export */ });
/* harmony import */ var _misc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./misc */ "./built/misc.js");

var WindowsIndexColorBitmap;
(function (WindowsIndexColorBitmap) {
    const bmp_file_header_size = 14;
    const bmp_info_header_size = 40;
    const palette_size = 4 * 256;
    const pixels_offset = bmp_file_header_size + bmp_info_header_size + palette_size;
    const Store16LE = function (bytes, offset, value) {
        bytes[offset + 0] = value & 0x00ff;
        bytes[offset + 1] = (value >> 8) & 0x00ff;
    };
    const Store32LE = function (bytes, offset, value) {
        bytes[offset + 0] = value & 0x000000ff;
        bytes[offset + 1] = (value >> 8) & 0x000000ff;
        bytes[offset + 2] = (value >> 16) & 0x000000ff;
        bytes[offset + 3] = (value >> 24) & 0x000000ff;
    };
    const Load16LE = function (bytes, offset) {
        return (bytes[offset + 0] & 0x00ff) | ((bytes[offset + 1] << 8) & 0xff00);
    };
    const Load32LE = function (bytes, offset) {
        return (bytes[offset + 0] & 0x000000ff)
            | ((bytes[offset + 1] << 8) & 0x0000ff00)
            | ((bytes[offset + 2] << 16) & 0x00ff0000)
            | ((bytes[offset + 3] << 14) & 0xff000000);
    };
    const RgbStringToRgbValues = function (rgb_string) {
        const [r_string, g_string, b_string] = rgb_string.split('(')[1].split(')')[0].split(',');
        return [Number(r_string), Number(g_string), Number(b_string)];
    };
    function Serialize(color_palette, pixels, width, height) {
        const bmp_width = Math.ceil(width / 4) * 4;
        const pixels_size = bmp_width * height;
        const binary_size = bmp_file_header_size + bmp_info_header_size + palette_size + pixels_size;
        const buffer = new ArrayBuffer(binary_size);
        const bytes = new Uint8Array(buffer);
        bytes[0] = 0x42;
        bytes[1] = 0x4d;
        /* Bitmap File Header */
        Store32LE(bytes, 2, binary_size);
        Store16LE(bytes, 6, 0);
        Store16LE(bytes, 8, 0);
        Store32LE(bytes, 10, pixels_offset);
        /* Bitmap Info Header */
        Store32LE(bytes, 14, 40);
        Store32LE(bytes, 18, width);
        Store32LE(bytes, 22, height);
        Store16LE(bytes, 26, 1);
        Store16LE(bytes, 28, 8);
        Store32LE(bytes, 30, 0);
        Store32LE(bytes, 34, pixels_size);
        Store32LE(bytes, 38, 0);
        Store32LE(bytes, 42, 0);
        Store32LE(bytes, 46, 256);
        Store32LE(bytes, 50, 256);
        /* Color palette */
        for (let i = 0; i < 256; i++) {
            const [r, g, b] = RgbStringToRgbValues(color_palette[i]);
            bytes[54 + 4 * i + 0] = b;
            bytes[54 + 4 * i + 1] = g;
            bytes[54 + 4 * i + 2] = r;
            bytes[54 + 4 * i + 3] = 0;
        }
        /* pixels */
        /* ラスタ座標系から数学座標系に入れ替えて出力する */
        for (let h = 0; h < height; h++) {
            for (let w = 0; w < width; w++) {
                let offset = pixels_offset + bmp_width * (height - h - 1) + w;
                bytes[offset] = pixels[h][w];
            }
        }
        return bytes;
    }
    WindowsIndexColorBitmap.Serialize = Serialize;
    function Deserialize(buffer) {
        const bytes = new Uint8Array(buffer);
        console.log(bytes[0]);
        console.log(bytes[1]);
        if (bytes[0] !== 0x42) {
            return null;
        }
        if (bytes[1] !== 0x4d) {
            return null;
        }
        if (Load32LE(bytes, 10) !== pixels_offset) {
            return null;
        }
        if (Load16LE(bytes, 26) !== 1) {
            return null;
        }
        if (Load16LE(bytes, 28) !== 8) {
            return null;
        }
        const width = Load32LE(bytes, 18);
        const height = Load32LE(bytes, 22);
        const bmp_width = Math.ceil(width / 4) * 4;
        const color_palette = new Array(256);
        for (let i = 0; i < 256; i++) {
            const b = bytes[54 + 4 * i + 0];
            const g = bytes[54 + 4 * i + 1];
            const r = bytes[54 + 4 * i + 2];
            color_palette[i] = `rgb(${r},${g},${b})`;
        }
        /* pixels */
        /* 数学座標系からラスタ座標系に入れ替えて読みこむ */
        const pixels = _misc__WEBPACK_IMPORTED_MODULE_0__.Misc.Make2dArray(width, height, 0);
        for (let h = 0; h < height; h++) {
            for (let w = 0; w < width; w++) {
                let offset = pixels_offset + bmp_width * (height - h - 1) + w;
                pixels[h][w] = bytes[offset];
            }
        }
        return [color_palette, pixels, width, height];
    }
    WindowsIndexColorBitmap.Deserialize = Deserialize;
})(WindowsIndexColorBitmap || (WindowsIndexColorBitmap = {}));


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!***********************!*\
  !*** ./built/main.js ***!
  \***********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _windows_bitmap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./windows_bitmap */ "./built/windows_bitmap.js");
/* harmony import */ var _misc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./misc */ "./built/misc.js");
/* harmony import */ var _browser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./browser */ "./built/browser.js");
/* harmony import */ var _gui_canvas__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./gui/canvas */ "./built/gui/canvas.js");
/* harmony import */ var _gui_color_palette__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./gui/color_palette */ "./built/gui/color_palette.js");
/* harmony import */ var _gui_download_button__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./gui/download_button */ "./built/gui/download_button.js");
/* harmony import */ var _gui_preview_window__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./gui/preview_window */ "./built/gui/preview_window.js");
/* harmony import */ var _gui_sprite_animation_preview_window__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./gui/sprite_animation_preview_window */ "./built/gui/sprite_animation_preview_window.js");
/* harmony import */ var _gui_layer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./gui/layer */ "./built/gui/layer.js");
/* harmony import */ var _gui_toolbox__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./gui/toolbox */ "./built/gui/toolbox.js");
/* harmony import */ var _gui_tab_pane__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./gui/tab_pane */ "./built/gui/tab_pane.js");
/* harmony import */ var _canvas_tools__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./canvas_tools */ "./built/canvas_tools.js");
/* harmony import */ var _rgb_color_palette__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./rgb_color_palette */ "./built/rgb_color_palette.js");
/* harmony import */ var _resources__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./resources */ "./built/resources.js");
/* harmony import */ var _dom_dom__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./dom/dom */ "./built/dom/dom.js");















const data_format_version = 1;
const max_edit_width = 512;
const max_edit_height = 512;
const default_edit_width = 32;
const default_edit_height = 32;
const default_edit_scale = 8;
const large_grid_color = '#ffff00';
class EditLogger {
    constructor() {
        this.undo_stack_ = new Array(0);
        this.redo_stack_ = new Array(0);
    }
    IsUndoLogEmpty() {
        return (this.undo_stack_.length === 0) ? true : false;
    }
    IsRedoLogEmpty() {
        return (this.redo_stack_.length === 0) ? true : false;
    }
    PushUndoLog(log_data) {
        this.undo_stack_.push(log_data);
    }
    PushRedoLog(log_data) {
        this.redo_stack_.push(log_data);
    }
    PopUndoLog() {
        return this.undo_stack_.pop();
    }
    PopRedoLog() {
        return this.redo_stack_.pop();
    }
    ClearRedoLog() {
        this.redo_stack_.splice(0);
    }
}
class IndexColorBitmap {
    constructor(width, height, color_palette, pixels) {
        this.width = width;
        this.height = height;
        this.color_palette = color_palette;
        this.pixels = pixels;
    }
    ;
}
class IndexColorBitmapLayer {
}
class MultiLayerIndexColorBitmap {
    constructor() {
        this.format_version = data_format_version;
    }
    Marge() {
        const num_layers = this.layers.length;
        const sorted_layers = new Array(num_layers);
        for (let layer of this.layers) {
            sorted_layers[num_layers - layer.order - 1] = layer;
        }
        const default_bg_color = 0;
        const max_w = this.width;
        const max_h = this.height;
        const bg_ci = default_bg_color;
        const marged_pixels = _misc__WEBPACK_IMPORTED_MODULE_1__.Misc.Make2dArray(max_w, max_h, 0);
        for (let h = 0; h < max_h; h++) {
            for (let w = 0; w < max_w; w++) {
                for (let i = 0; i < sorted_layers.length; i++) {
                    const source_layer = sorted_layers[i];
                    const src_ci = source_layer.pixels[h][w];
                    if (src_ci !== bg_ci) {
                        marged_pixels[h][w] = src_ci;
                        break;
                    }
                }
            }
        }
        const color_palette = _misc__WEBPACK_IMPORTED_MODULE_1__.Misc.GenerateArray(256, (i) => {
            return this.color_palette[i].ToRgbString();
        });
        return new IndexColorBitmap(max_w, max_h, color_palette, marged_pixels);
    }
}
class PixelLayer {
    constructor(order, name, tag_color, max_width, max_height) {
        this.pixels = _misc__WEBPACK_IMPORTED_MODULE_1__.Misc.Make2dArray(max_width, max_height, 0);
        this.order = order;
        this.name = name;
        this.tag_color = tag_color;
        this.is_locked = false;
        this.is_visible = true;
    }
    CalculateHistogram(width, height) {
        const histogram = new Array(256).fill(0);
        const max_height = this.pixels.length;
        const max_width = this.pixels[0].length;
        const actual_height = ((height < max_height) ? height : max_height);
        const actual_width = ((width < max_width) ? width : max_width);
        for (let h = 0; h < actual_height; h++) {
            for (let w = 0; w < actual_width; w++) {
                histogram[this.pixels[h][w]]++;
            }
        }
        return histogram;
    }
    SwapColor(lh_index, rh_index) {
        const max_height = this.pixels.length;
        const max_width = this.pixels[0].length;
        for (let h = 0; h < max_height; h++) {
            for (let w = 0; w < max_width; w++) {
                const color_index = this.pixels[h][w];
                if (color_index === lh_index) {
                    this.pixels[h][w] = rh_index;
                }
                if (color_index === rh_index) {
                    this.pixels[h][w] = lh_index;
                }
            }
        }
        return;
    }
}
class Data {
    constructor(default_width, default_height, max_width, max_height) {
        this.edit_width_ = default_width;
        this.edit_height_ = default_height;
        this.max_width_ = max_width;
        this.max_height_ = max_height;
        this.current_pixel_layer_ = null;
        this.pixel_layers_ = new Map();
        this.pixels_clipboard_ = _misc__WEBPACK_IMPORTED_MODULE_1__.Misc.Make2dArray(max_width, max_height, 0);
        this.clipboard_stored_width_ = 0;
        this.clipboard_stored_height_ = 0;
        this.pixels_mask_ = _misc__WEBPACK_IMPORTED_MODULE_1__.Misc.Make2dArray(max_width, max_height, false);
        this.selected_color_index_ = 0;
        this.selected_bg_color_index_ = 0;
        this.color_palette_ = new _rgb_color_palette__WEBPACK_IMPORTED_MODULE_12__.RgbColorPalette();
        this.logger_ = new EditLogger();
        this.created_layer_count_ = 0;
    }
    AutoCreateLayerDefaultParameters() {
        const hue = (this.created_layer_count_ * 79) % 360;
        const color = new _rgb_color_palette__WEBPACK_IMPORTED_MODULE_12__.RgbColor(..._misc__WEBPACK_IMPORTED_MODULE_1__.Misc.HsvToRgb(hue, 0.375, 0.75));
        const name = `new layer #${this.created_layer_count_}`;
        this.created_layer_count_++;
        return [name, color.ToHexColor()];
    }
    SetCurrentPixelLayer(pixel_layer) {
        this.current_pixel_layer_ = pixel_layer;
    }
    IsCurrentPixelLayer(pixel_layer) {
        return (this.current_pixel_layer_ === pixel_layer);
    }
    get edit_width() {
        return this.edit_width_;
    }
    set edit_width(new_width) {
        this.edit_width_ = new_width;
    }
    get edit_height() {
        return this.edit_height_;
    }
    set edit_height(new_height) {
        this.edit_height_ = new_height;
    }
    get selected_color_index() {
        return this.selected_color_index_;
    }
    set selected_color_index(new_index) {
        this.selected_color_index_ = new_index;
    }
    get selected_bg_color_index() {
        return this.selected_bg_color_index_;
    }
    InsertNewLayer(order) {
        const layer_params = this.AutoCreateLayerDefaultParameters();
        const new_pixel_layer = new PixelLayer(order, ...layer_params, this.max_width_, this.max_height_);
        data.AppendLayer(new_pixel_layer);
        return [...layer_params, new_pixel_layer];
    }
    AppendLayer(pixel_layer) {
        this.pixel_layers_.set(pixel_layer, pixel_layer);
        if (this.current_pixel_layer_ === null) {
            this.current_pixel_layer_ = pixel_layer;
        }
    }
    RemoveLayer(pixel_layer) {
        this.pixel_layers_.delete(pixel_layer);
        if (this.current_pixel_layer_ === pixel_layer) {
            this.current_pixel_layer_ = null;
        }
    }
    RemoveAllLayers() {
        this.pixel_layers_.clear();
        this.current_pixel_layer_ = null;
    }
    SetMaskFlagsByRectangle(left, top, right, bottom, flag) {
        for (let h = top; h <= bottom; h++) {
            for (let w = left; w <= right; w++) {
                this.pixels_mask_[h][w] = flag;
            }
        }
    }
    TurnMask() {
        for (let h = 0; h < this.edit_height_; h++) {
            for (let w = 0; w < this.edit_width_; w++) {
                this.pixels_mask_[h][w] = !this.pixels_mask_[h][w];
            }
        }
    }
    IsMasked(w, h) {
        return this.pixels_mask_[h][w];
    }
    get pixels_mask() {
        return this.pixels_mask_;
    }
    WriteMap(w, h, color_index) {
        if (this.IsMasked(w, h)) {
            return;
        }
        if (this.current_pixel_layer_.is_locked === true) {
            return;
        }
        this.current_pixel_layer_.pixels[h][w] = color_index;
    }
    GetWrittenColorIndex(w, h) {
        return this.current_pixel_layer_.pixels[h][w];
    }
    GetRgbColorFromPalette(index) {
        return this.color_palette_.GetColor(index);
    }
    GetColorTable() {
        const color_table = _misc__WEBPACK_IMPORTED_MODULE_1__.Misc.GenerateArray(256, (i) => {
            return this.color_palette_.GetColor(i).ToHexColor();
        });
        return color_table;
    }
    DeleteAllUnusedColors() {
        const histogram = _misc__WEBPACK_IMPORTED_MODULE_1__.Misc.GenerateArray(256, (index) => { return 0; });
        for (const layer of this.pixel_layers_.values()) {
            const histogram_tmp = layer.CalculateHistogram(this.edit_width_, this.edit_height_);
            for (let i = 0; i < 256; i++) {
                histogram[i] += histogram_tmp[i];
            }
        }
        for (let i = 0; i < 256; i++) {
            if (histogram[i] === 0) {
                data.color_palette_.SetPresetColor(i, "black");
            }
        }
    }
    SwapColor(lh_index, rh_index) {
        if (lh_index === rh_index) {
            return;
        }
        this.current_pixel_layer_.SwapColor(lh_index, rh_index);
        this.color_palette_.SwapColor(lh_index, rh_index);
        return;
    }
    GetDescendingOrderedLayers() {
        const num_layers = this.pixel_layers_.size;
        const sorted_layers = new Array(num_layers);
        for (let layer of this.pixel_layers_.values()) {
            sorted_layers[num_layers - layer.order - 1] = layer;
        }
        return sorted_layers;
    }
    GetUnorderedLayersIterator() {
        return this.pixel_layers_.values();
    }
    CreateLayerCreationParameters() {
        const creation_parameters = new Array(0);
        for (const pixel_layer of this.pixel_layers_.values()) {
            creation_parameters.push([pixel_layer.order, pixel_layer.name, pixel_layer.tag_color, pixel_layer]);
        }
        return creation_parameters;
    }
    MakeSaveData() {
        const edit_w_count = this.edit_width_;
        const edit_h_count = this.edit_height_;
        const color_palette = _misc__WEBPACK_IMPORTED_MODULE_1__.Misc.GenerateArray(256, (i) => {
            return this.color_palette_.GetColor(i);
        });
        const save_data = new MultiLayerIndexColorBitmap();
        save_data.width = edit_w_count;
        save_data.height = edit_h_count;
        save_data.color_palette = color_palette;
        save_data.layers = new Array(0);
        for (let layer of this.pixel_layers_.values()) {
            const save_layer = new IndexColorBitmapLayer();
            save_layer.order = layer.order;
            save_layer.name = layer.name;
            save_layer.tag_color = layer.tag_color;
            save_layer.pixels = _misc__WEBPACK_IMPORTED_MODULE_1__.Misc.Make2dArray(edit_w_count, edit_h_count, 0);
            for (let h = 0; h < edit_h_count; h++) {
                for (let w = 0; w < edit_w_count; w++) {
                    save_layer.pixels[h][w] = layer.pixels[h][w];
                }
            }
            save_data.layers.push(save_layer);
        }
        return save_data;
    }
    ConstructViewPixelsForViewInplace(pixels_for_view) {
        const sorted_layers = this.GetDescendingOrderedLayers();
        const max_w = this.edit_width;
        const max_h = this.edit_height;
        const bg_ci = this.selected_bg_color_index;
        const lowest_layer_index = sorted_layers.length - 1;
        for (let h = 0; h < max_h; h++) {
            for (let w = 0; w < max_w; w++) {
                let is_written = false;
                for (let i = 0; i < sorted_layers.length - 1; i++) {
                    const source_layer = sorted_layers[i];
                    if (source_layer.is_visible === false) {
                        continue;
                    }
                    const src_ci = source_layer.pixels[h][w];
                    if (src_ci !== bg_ci) {
                        pixels_for_view[h][w] = src_ci;
                        is_written = true;
                        break;
                    }
                }
                if (!is_written) {
                    if (sorted_layers[lowest_layer_index].is_visible) {
                        pixels_for_view[h][w] = sorted_layers[lowest_layer_index].pixels[h][w];
                    }
                    else {
                        pixels_for_view[h][w] = bg_ci;
                    }
                }
            }
        }
        return;
    }
    CopyFromIndexColorBitmap(bmp_data, name) {
        const edit_w = bmp_data.width;
        const edit_h = bmp_data.height;
        this.edit_width_ = edit_w;
        this.edit_height_ = edit_h;
        for (let i = 0; i < 256; i++) {
            this.color_palette_.SetColorByString(i, bmp_data.color_palette[i]);
        }
        this.pixel_layers_.clear();
        const layer = new PixelLayer(0, name, '#90b080', max_edit_width, max_edit_height);
        for (let h = 0; h < edit_h; h++) {
            for (let w = 0; w < edit_w; w++) {
                layer.pixels[h][w] = bmp_data.pixels[h][w];
            }
        }
        this.pixel_layers_.set(layer, layer);
        return;
    }
    CopyFromMultiLayerIndexColorBitmap(raw_data) {
        const edit_w = raw_data.width;
        const edit_h = raw_data.height;
        this.edit_width_ = edit_w;
        this.edit_height_ = edit_h;
        for (let i = 0; i < 256; i++) {
            this.color_palette_.SetColor(i, raw_data.color_palette[i]);
        }
        this.pixel_layers_.clear();
        for (let raw_layer of raw_data.layers) {
            const layer = new PixelLayer(raw_layer.order, raw_layer.name, raw_layer.tag_color, max_edit_width, max_edit_height);
            for (let h = 0; h < edit_h; h++) {
                for (let w = 0; w < edit_w; w++) {
                    layer.pixels[h][w] = raw_layer.pixels[h][w];
                }
            }
            this.pixel_layers_.set(layer, layer);
        }
        return;
    }
    CopyToClipBoard(left, top, right, bottom) {
        const copy_w = right - left + 1;
        const copy_h = bottom - top + 1;
        for (let dst_h = 0; dst_h < copy_h; dst_h++) {
            const src_h = top + dst_h;
            for (let dst_w = 0; dst_w < copy_w; dst_w++) {
                const src_w = left + dst_w;
                this.pixels_clipboard_[dst_h][dst_w] = this.current_pixel_layer_.pixels[src_h][src_w];
            }
        }
        this.clipboard_stored_width_ = copy_w;
        this.clipboard_stored_height_ = copy_h;
    }
    PasteToCanvas(left, top) {
        const paste_w = Math.min(this.clipboard_stored_width_, this.edit_width_ - left);
        const paste_h = Math.min(this.clipboard_stored_height_, this.edit_height_ - top);
        for (let src_h = 0; src_h < paste_h; src_h++) {
            const dst_h = top + src_h;
            for (let src_w = 0; src_w < paste_w; src_w++) {
                if (this.selected_bg_color_index_ !== this.pixels_clipboard_[src_h][src_w]) {
                    const dst_w = left + src_w;
                    data.WriteMap(dst_w, dst_h, this.pixels_clipboard_[src_h][src_w]);
                }
            }
        }
    }
    PushUndoLog() {
        const current_data = data.MakeSaveData();
        this.logger_.PushUndoLog(current_data);
        this.logger_.ClearRedoLog();
        AutoSave();
    }
    Undo() {
        if (this.logger_.IsUndoLogEmpty()) {
            return;
        }
        const current_data = data.MakeSaveData();
        this.logger_.PushRedoLog(current_data);
        const undo_data = this.logger_.PopUndoLog();
        this.CopyFromMultiLayerIndexColorBitmap(undo_data);
        layer_pane_ui.CreateBrandNewLayers(this.CreateLayerCreationParameters());
    }
    Redo() {
        if (this.logger_.IsRedoLogEmpty()) {
            return;
        }
        const current_data = data.MakeSaveData();
        this.logger_.PushUndoLog(current_data);
        const redo_data = this.logger_.PopRedoLog();
        this.CopyFromMultiLayerIndexColorBitmap(redo_data);
        layer_pane_ui.CreateBrandNewLayers(data.CreateLayerCreationParameters());
    }
}
const ApplyView = function () {
    color_table.SetColorTable(data.GetColorTable());
    if (canvas_ui !== null) {
        canvas_ui.canvas_width = data.edit_width;
        canvas_ui.canvas_height = data.edit_height;
    }
    return;
};
class RectangleTargetPixels {
    constructor(x1, y1, x2, y2) {
        this.Update(x1, y1, x2, y2);
    }
    Update(x1, y1, x2, y2) {
        this.left = (x1 < x2) ? x1 : x2;
        this.right = (x1 < x2) ? x2 : x1;
        this.top = (y1 < y2) ? y1 : y2;
        this.bottom = (y1 < y2) ? y2 : y1;
    }
    In(point) {
        const is_contain = ((this.left <= point.w) && (point.w <= this.right) &&
            (this.top <= point.h) && (point.h <= this.bottom));
        return is_contain;
    }
    BrakedownToPixelMask() {
        data.SetMaskFlagsByRectangle(this.left, this.top, this.right, this.bottom, true);
    }
    VerticalTurn() {
        const half_h = Number(Math.floor((this.bottom - this.top + 1) / 2));
        const max_h = this.top + half_h;
        for (let h1 = this.top, h2 = this.bottom; h1 < max_h; h1++, h2--) {
            for (let w = this.left; w <= this.right; w++) {
                const c1 = data.GetWrittenColorIndex(w, h1);
                const c2 = data.GetWrittenColorIndex(w, h2);
                data.WriteMap(w, h1, c2);
                data.WriteMap(w, h2, c1);
            }
        }
    }
    HorizontalTurn() {
        const half_w = Number(Math.floor((this.right - this.left + 1) / 2));
        const max_w = this.left + half_w;
        for (let w1 = this.left, w2 = this.right; w1 < max_w; w1++, w2--) {
            for (let h = this.top; h <= this.bottom; h++) {
                const c1 = data.GetWrittenColorIndex(w1, h);
                const c2 = data.GetWrittenColorIndex(w2, h);
                data.WriteMap(w1, h, c2);
                data.WriteMap(w2, h, c1);
            }
        }
    }
    Fill() {
        const current_color_index = data.selected_color_index;
        for (let h = this.top; h <= this.bottom; h++) {
            for (let w = this.left; w <= this.right; w++) {
                data.WriteMap(w, h, current_color_index);
            }
        }
    }
    CopyToClipboard() {
        data.CopyToClipBoard(this.left, this.top, this.right, this.bottom);
    }
    Paste() {
        data.PushUndoLog();
        data.PasteToCanvas(this.left, this.top);
    }
    get rectangle() {
        return { left: this.left, top: this.top, right: this.right, bottom: this.bottom };
    }
}
const data = new Data(default_edit_width, default_edit_height, max_edit_width, max_edit_height);
const marged_pixels_for_view = _misc__WEBPACK_IMPORTED_MODULE_1__.Misc.Make2dArray(max_edit_width, max_edit_height, 0);
let canvas_ui = null;
const DrawPen1px = function (x, y) {
    data.WriteMap(x, y, data.selected_color_index);
};
const DrawPen2px = function (x, y) {
    const color_index = data.selected_color_index;
    data.WriteMap(x, y, color_index);
    if (0 < x) {
        data.WriteMap(x - 1, y, color_index);
    }
    if (0 < y) {
        data.WriteMap(x, y - 1, color_index);
    }
    if ((0 < x) && (0 < y)) {
        data.WriteMap(x - 1, y - 1, color_index);
    }
};
const DrawPen3px = function (x, y) {
    const color_index = data.selected_color_index;
    data.WriteMap(x, y, color_index);
    if (0 < x) {
        data.WriteMap(x - 1, y, color_index);
        if (0 < y) {
            data.WriteMap(x, y - 1, color_index);
            data.WriteMap(x - 1, y - 1, color_index);
        }
        if (y < canvas_ui.canvas_height - 1) {
            data.WriteMap(x, y + 1, color_index);
            data.WriteMap(x - 1, y + 1, color_index);
        }
    }
    if (x < canvas_ui.canvas_width - 1) {
        data.WriteMap(x + 1, y, color_index);
        if (0 < y) {
            data.WriteMap(x + 1, y - 1, color_index);
        }
        if (y < canvas_ui.canvas_height - 1) {
            data.WriteMap(x + 1, y + 1, color_index);
        }
    }
};
let DrawPen = DrawPen1px;
const canvas_tools = new _canvas_tools__WEBPACK_IMPORTED_MODULE_11__.CanvasTools.CanvasTools((x, y) => {
    return !data.IsMasked(x, y);
}, (x, y) => {
    if (x < 0 || y < 0 || canvas_ui.canvas_width <= x || canvas_ui.canvas_height <= y) {
        return;
    }
    DrawPen(x, y);
}, (x, y) => {
    return data.GetWrittenColorIndex(x, y);
}, () => {
    return [canvas_ui.canvas_width, canvas_ui.canvas_height];
}, () => {
    return canvas_ui.edit_scale;
}, (x, y) => {
    const color_index = data.GetWrittenColorIndex(x, y);
    ChengeCurrentColor(color_index);
}, (start_x, start_y, end_x, end_y) => {
    if (target_pixels === null) {
        target_pixels = new RectangleTargetPixels(start_x, start_y, end_x, end_y);
    }
    else {
        target_pixels.Update(start_x, start_y, end_x, end_y);
    }
}, () => { }, () => {
    data.PushUndoLog();
}, () => { }, () => { });
let layer_pane_ui = null;
let target_pixels = null;
let color_table = null;
let preview_window = null;
let animation_window = null;
let preview_tab_pane = null;
function GetHtmlElement(element_id) {
    return document.getElementById(element_id);
}
const TryReadEditDataByJson = function (bytes) {
    const read_data = JSON.parse(bytes);
    data.CopyFromMultiLayerIndexColorBitmap(read_data);
    layer_pane_ui.CreateBrandNewLayers(data.CreateLayerCreationParameters());
    ApplyView();
    return true;
};
const LoadEditData = function (bytes) {
    const bmp_data = _windows_bitmap__WEBPACK_IMPORTED_MODULE_0__.WindowsIndexColorBitmap.Deserialize(bytes);
    if (bmp_data !== null) {
        const [color_palette, pixels, width, height] = bmp_data;
        const raw_data = new IndexColorBitmap(width, height, color_palette, pixels);
        data.CopyFromIndexColorBitmap(raw_data, dom.edit_data_name.value);
        layer_pane_ui.CreateBrandNewLayers(data.CreateLayerCreationParameters());
        ApplyView();
        return true;
    }
    const bs = Array.from(new Uint8Array(bytes), (v) => String.fromCharCode(v)).join("");
    if (TryReadEditDataByJson(bs)) {
        return true;
    }
    return false;
};
class GlobalDom {
    Initialize() {
        this.blank_frame = GetHtmlElement('blank_frame');
        this.edit_block = GetHtmlElement('editblock');
        this.edit_filepath = GetHtmlElement('edit_filepath');
        this.large_grid_width = GetHtmlElement('large_grid_width');
        this.large_grid_height = GetHtmlElement('large_grid_height');
        this.grid_color = GetHtmlElement('grid_color');
        this.edit_data_name = GetHtmlElement('edit_data_name');
        this.undo_button = GetHtmlElement('undo_button');
        this.redo_button = GetHtmlElement('redo_button');
        this.clear_button = GetHtmlElement('clear_button');
        this.rectangle_fill_button = GetHtmlElement('rectangle_fill_button');
        this.h_turn_button = GetHtmlElement('h_turn_button');
        this.v_turn_button = GetHtmlElement('v_turn_button');
        this.break_to_mask_button = GetHtmlElement('break_to_mask_button');
        this.release_targetting_button = GetHtmlElement('release_targetting_button');
        this.turn_mask_button = GetHtmlElement('turn_mask_button');
        this.delete_mask_button = GetHtmlElement('delete_mask_button');
        this.delete_all_unused_colors_button = GetHtmlElement('delete_all_unused_colors_button');
    }
}
const dom = new GlobalDom();
var frame_count = 0;
const UpdateView = function () {
    data.ConstructViewPixelsForViewInplace(marged_pixels_for_view);
    layer_pane_ui.Draw();
    const color_table = data.GetColorTable();
    if (preview_window !== null) {
        preview_window.Draw(marged_pixels_for_view, color_table, data.edit_width, data.edit_height);
    }
    if (animation_window !== null) {
        animation_window.Draw(marged_pixels_for_view, color_table, data.edit_width, data.edit_height, frame_count);
    }
    if (canvas_ui !== null) {
        canvas_ui.Draw(marged_pixels_for_view, data.pixels_mask, color_table, dom.grid_color.value, dom.large_grid_width.valueAsNumber, dom.large_grid_height.valueAsNumber, large_grid_color, ((target_pixels !== null) ? target_pixels.rectangle : null), frame_count);
    }
    frame_count++;
    window.requestAnimationFrame(UpdateView);
};
const ChengeCurrentColor = function (new_color_index) {
    data.selected_color_index = new_color_index;
    color_table.SelectColorCell(new_color_index);
};
const AutoSave = function () {
    if (_browser__WEBPACK_IMPORTED_MODULE_2__.Browser.isStorageAvailable('localStorage')) {
        window.localStorage.setItem('data', JSON.stringify(data.MakeSaveData()));
    }
};
const AutoLoad = function () {
    if (_browser__WEBPACK_IMPORTED_MODULE_2__.Browser.isStorageAvailable('localStorage') == false) {
        return false;
    }
    const data_json = window.localStorage.getItem('data');
    if (data_json === null) {
        return false;
    }
    const load_data = JSON.parse(data_json);
    if (('format_version' in load_data) == false) {
        window.localStorage.removeItem('data');
        return false;
    }
    if (load_data.format_version !== data_format_version) {
        window.localStorage.removeItem('data');
        return false;
    }
    data.CopyFromMultiLayerIndexColorBitmap(load_data);
    return true;
};
function Initialize() {
    dom.Initialize();
    const edit_reader = new FileReader();
    dom.edit_filepath.addEventListener('change', (event) => {
        edit_reader.readAsArrayBuffer(event.target.files[0]);
    });
    new _gui_download_button__WEBPACK_IMPORTED_MODULE_5__.DonwloadButton(GetHtmlElement("edit_command"), "保存（ダウンロード）", () => {
        const basename = dom.edit_data_name.value;
        const save_format = GetHtmlElement('edit_save_format').value;
        return MakeSaveData(basename, save_format);
    });
    edit_reader.addEventListener('load', (event) => {
        const basename = _misc__WEBPACK_IMPORTED_MODULE_1__.Misc.ExtractBaseName(dom.edit_filepath.value);
        dom.edit_data_name.value = basename;
        LoadEditData(event.target.result);
    });
    color_table = new _gui_color_palette__WEBPACK_IMPORTED_MODULE_4__.ColorPaletteTableUi(16, 16, 16, 0, [
        { caption: "HSV 16色", colors: _misc__WEBPACK_IMPORTED_MODULE_1__.Misc.MakeHSVBalancedColorList(1) },
        { caption: "HSV 16色2彩度", colors: _misc__WEBPACK_IMPORTED_MODULE_1__.Misc.MakeHSVBalancedColorList(2) },
        { caption: "HSV 16色4彩度", colors: _misc__WEBPACK_IMPORTED_MODULE_1__.Misc.MakeHSVBalancedColorList(4) },
        { caption: "Webセーフカラー", colors: _misc__WEBPACK_IMPORTED_MODULE_1__.Misc.MakeWebSafeColorList() },
    ], (color_index) => {
        data.selected_color_index = color_index;
    }, (src_i, src_cc, dst_i, dst_cc) => {
        data.SwapColor(src_i, dst_i);
    }, (color_index, color_string) => {
        data.GetRgbColorFromPalette(color_index).SetHexColor(color_string);
    });
    document.getElementById("colorpalette").appendChild(color_table.node);
    if (!AutoLoad()) {
        data.RemoveAllLayers();
        data.InsertNewLayer(0);
    }
    ApplyView();
    if (canvas_ui === null) {
        canvas_ui = new _gui_canvas__WEBPACK_IMPORTED_MODULE_3__.CanvasUi(data.edit_width, data.edit_height, (width, height) => {
            data.edit_width = width;
            data.edit_height = height;
        });
        canvas_ui.edit_scale = default_edit_scale;
    }
    canvas_tools.Attach(canvas_ui.canvas);
    dom.edit_block.appendChild(canvas_ui.node);
    dom.undo_button.addEventListener('click', (event) => {
        data.Undo();
        ApplyView();
    });
    dom.redo_button.addEventListener('click', (event) => {
        data.Redo();
        ApplyView();
    });
    dom.clear_button.addEventListener('click', (event) => {
        data.PushUndoLog();
        data.RemoveAllLayers();
        data.InsertNewLayer(0);
        layer_pane_ui.CreateBrandNewLayers(data.CreateLayerCreationParameters());
        ApplyView();
    });
    dom.rectangle_fill_button.addEventListener('click', (event) => {
        if (target_pixels !== null) {
            data.PushUndoLog();
            target_pixels.Fill();
        }
    });
    dom.v_turn_button.addEventListener('click', (event) => {
        if (target_pixels !== null) {
            target_pixels.VerticalTurn();
        }
    });
    dom.h_turn_button.addEventListener('click', (event) => {
        if (target_pixels !== null) {
            target_pixels.HorizontalTurn();
        }
    });
    dom.break_to_mask_button.addEventListener('click', (event) => {
        if (target_pixels !== null) {
            target_pixels.BrakedownToPixelMask();
        }
    });
    dom.release_targetting_button.addEventListener('click', (event) => {
        target_pixels = null;
    });
    dom.turn_mask_button.addEventListener('click', (event) => {
        data.TurnMask();
    });
    dom.delete_mask_button.addEventListener('click', (event) => {
        data.SetMaskFlagsByRectangle(0, 0, data.edit_width, data.edit_height, false);
    });
    dom.delete_all_unused_colors_button.addEventListener('click', (event) => {
        data.DeleteAllUnusedColors();
        color_table.SetColorTable(data.GetColorTable());
    });
    const layers = document.getElementById("layerblock");
    layer_pane_ui = new _gui_layer__WEBPACK_IMPORTED_MODULE_8__.LayerPaneUi((order) => {
        return data.InsertNewLayer(order);
    }, (pixel_layer, order) => {
        data.RemoveLayer(pixel_layer);
    }, (lh_order, rh_order) => { }, (pixel_layer, order, name, tag_color, is_locked, is_visible, is_focusin, is_focusout, thumbnail_context) => {
        pixel_layer.order = order;
        pixel_layer.name = name;
        pixel_layer.is_locked = is_locked;
        pixel_layer.is_visible = is_visible;
        if (is_focusin === true) {
            data.SetCurrentPixelLayer(pixel_layer);
            dom.edit_block.style.backgroundColor = tag_color;
            canvas_ui.node.style.backgroundColor = tag_color;
        }
        if (data.IsCurrentPixelLayer(pixel_layer)) {
            if (canvas_ui !== null) {
                if (is_locked) {
                    canvas_ui.canvas.style.cursor = 'not-allowed';
                }
                else {
                    canvas_ui.canvas.style.cursor = 'auto';
                }
            }
        }
    }, (value, order, is_locked, is_visible, thumbnail_context) => {
        thumbnail_context.scale(1, 1);
        thumbnail_context.fillStyle = '#000000';
        thumbnail_context.fillRect(0, 0, 16, 16);
        if (is_locked) {
            thumbnail_context.moveTo(0.5, 0.5);
            thumbnail_context.lineTo(15.5, 15.5);
            thumbnail_context.lineWidth = 3;
            thumbnail_context.strokeStyle = '#ff0000';
            thumbnail_context.stroke();
        }
    }, (event_kind) => {
        data.PushUndoLog();
    });
    layers.appendChild(layer_pane_ui.node);
    layer_pane_ui.CreateBrandNewLayers(data.CreateLayerCreationParameters());
    preview_tab_pane = new _gui_tab_pane__WEBPACK_IMPORTED_MODULE_10__.TabPaneUi();
    preview_window = new _gui_preview_window__WEBPACK_IMPORTED_MODULE_6__.PreviewWindowUi(data.edit_width, data.edit_height);
    animation_window = new _gui_sprite_animation_preview_window__WEBPACK_IMPORTED_MODULE_7__.SpriteAnimationPreviewWindowUi(16, 16);
    preview_window.node.style.backgroundColor = "darkgoldenrod";
    animation_window.node.style.backgroundColor = "olive";
    preview_tab_pane.AddTab(preview_window.node, "プレビュー");
    preview_tab_pane.AddTab(animation_window.node, "アニメ");
    document.getElementById("viewblock").appendChild(preview_tab_pane.node);
    window.addEventListener('keydown', (event) => {
        if (event.ctrlKey) {
            switch (event.key) {
                case 's':
                    AutoSave();
                    break;
                case 'z':
                    data.Undo();
                    ApplyView();
                    break;
                case 'y':
                    data.Redo();
                    ApplyView();
                    break;
                case 'd':
                    target_pixels = null;
                    break;
                case 'c':
                    if (!!target_pixels) {
                        target_pixels.CopyToClipboard();
                    }
                    break;
                case 'v':
                    if (!!target_pixels) {
                        target_pixels.Paste();
                    }
                    else {
                        data.PushUndoLog();
                        data.PasteToCanvas(0, 0);
                    }
                    break;
            }
        }
    });
    const toolsblock = GetHtmlElement("toolpanel");
    const toolbox = new _gui_toolbox__WEBPACK_IMPORTED_MODULE_9__.ToolBoxUi([
        { kind: "pen", title: "ペン", base64icon: _resources__WEBPACK_IMPORTED_MODULE_13__.Resources.tool_icon_pen },
        { kind: "paint", title: "塗り潰し", base64icon: _resources__WEBPACK_IMPORTED_MODULE_13__.Resources.tool_icon_fill },
        { kind: "rectangle_select", title: "矩形選択", base64icon: _resources__WEBPACK_IMPORTED_MODULE_13__.Resources.tool_icon_select },
    ], (pre, post) => {
        canvas_tools.tool_kind = post;
    });
    toolsblock.appendChild(toolbox.node);
    const tooloptions = GetHtmlElement("tooloptions");
    const pen_width_selector = _dom_dom__WEBPACK_IMPORTED_MODULE_14__.Dom.CreateSelector([1, 2, 3], (index, item) => { return `${item}px`; }, 0);
    pen_width_selector.addEventListener("change", (event) => {
        const pen_width = parseInt(event.target.value);
        switch (pen_width) {
            case 1:
                DrawPen = DrawPen1px;
                break;
            case 2:
                DrawPen = DrawPen2px;
                break;
            case 3:
                DrawPen = DrawPen3px;
                break;
        }
    });
    const pen_width_holder = document.createElement("div");
    pen_width_holder.appendChild(_dom_dom__WEBPACK_IMPORTED_MODULE_14__.Dom.CreateText("ペンの太さ"));
    pen_width_holder.appendChild(pen_width_selector);
    tooloptions.appendChild(pen_width_holder);
    window.requestAnimationFrame(UpdateView);
}
const MakeSaveDataBlobAsWindowsIndexColorBitmap = function (save_data) {
    const index_bmp = save_data.Marge();
    const bmp_bytes = _windows_bitmap__WEBPACK_IMPORTED_MODULE_0__.WindowsIndexColorBitmap.Serialize(index_bmp.color_palette, index_bmp.pixels, index_bmp.width, index_bmp.height);
    const save_data_blob = new Blob([bmp_bytes]);
    return save_data_blob;
};
const MakeSaveDataBlobAsJson = function (save_data) {
    const save_data_json = JSON.stringify(save_data);
    const save_data_blob = new Blob([save_data_json], {
        type: 'application/json'
    });
    return save_data_blob;
};
const MakeSaveData = function (basename, save_format) {
    switch (save_format) {
        case "WindowsIndexColorBitmap":
            return [`${basename}.bmp`, MakeSaveDataBlobAsWindowsIndexColorBitmap(data.MakeSaveData())];
        case "JSON":
        default:
            return [`${basename}.json`, MakeSaveDataBlobAsJson(data.MakeSaveData())];
    }
};
Initialize();

})();

/******/ })()
;</script></body>

</html>