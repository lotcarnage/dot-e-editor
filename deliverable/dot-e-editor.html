<html lang="ja">

<head>
    <title>ドット絵エディター</title>
    <meta charset="UTF-8">
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        body {
            background-color: darkgray;
        }

        input[type="number"] {
            font-size: 24px;
            width: 96px;
            text-align: right;
        }

        div#viewframe {
            width: 96px;
            height: 96px;
            overflow: scroll;
            resize: both;
            text-align: center;
        }

        div#viewblock {
            float: left;
            background-color: darkgoldenrod;
        }

        div#editframe {
            width: 32px;
            height: 384px;
            overflow: scroll;
            resize: both;
            text-align: center;
        }

        div#settingsblock {
            background-color: darkgrey;
        }

        div#editblock {
            float: left;
            background-color: darkolivegreen;
        }

        div#mapchipblock {
            text-align: center;
            float: left;
            background-color: darkslateblue;
        }

        div#mapchipsblock {
            float: left;
            background-color: darkseagreen;
        }
    </style>
</head>

<body>
    <div id="settingsblock">
        <input type="checkbox" id="view_index">
        <label for="view_index">色番号表示</label>
        <input type="checkbox" id="view_grid" checked>
        <label for="view_grid">グリッド表示</label>
        <input type="color" id="grid_color" value="#333333">
        <label for="grid_color">グリッド／番号色</label>
        <input type="color" id="canvas_bg_color" value="#ff00ff">
        <label for="canvas_bg_color">キャンバス背景色</label>
    </div>
    <div id="viewblock">
        <p>
            表示倍率
            <select id="view_scale">
                <option value="1">x1</option>
                <option value="2">x2</option>
                <option value="3">x3</option>
                <option value="4" selected>x4</option>
                <option value="6">x6</option>
                <option value="8">x8</option>
                <option value="12">x12</option>
                <option value="16">x16</option>
                <option value="24">x24</option>
            </select>
        </p>
        <div id="viewframe">
            <canvas id="view" width="32" height="32"></canvas>
        </div>
    </div>
    <div id="editblock">
        <p>
            横ピクセル数<input id="editwidth" type="number" min="1">
            縦ピクセル数<input id="editheight" type="number" min="1">
            編集画面表示倍率
            <select id="edit_scale">
                <option value="1">x1</option>
                <option value="2">x2</option>
                <option value="4" selected>x4</option>
                <option value="8">x8</option>
                <option value="16">x16</option>
                <option value="24">x24</option>
                <option value="32">x32</option>
            </select>
        </p>
        <p>
            読み込み<input type="file" id="edit_filepath">
        </p>
        <p>
            保存形式
            <select id="edit_save_format">
                <option value="WindowsIndexColorBitmap" selected>BMP</option>
                <option value="JSON">JSON</option>
            </select>
            <input type="text" id="edit_data_name" value="new_picture">
            <a id="download_edit_data" href="#"><button>保存(ダウンロード)</button></a>
        </p>
        <div id="editframe">
            <canvas id="edit" width="256" height="192" onContextmenu="return false;"></canvas>
        </div>
    </div>
    <div>
        <p>
            <button id="undo_button">Undo(Ctrl+z)</button>
            <button id="redo_button">Redo(Ctrl+y)</button>
        </p>
        <p>
            <input type="radio" name="tools" id="pen_tool" value="pen_tool" checked>
            <label for="pen_tool">ペン</label>
            <input type="radio" name="tools" id="paint_tool" value="paint_tool">
            <label for="paint_tool">塗りつぶし</label>
        </p>
        <p>
            <input type="radio" name="tools" id="rectangle_select_tool" value="rectangle_select_tool">
            <label for="rectangle_select_tool">矩形選択</label>
            <button id="v_turn_button">上下反転</button>
            <button id="h_turn_button">左右反転</button>
            <button id="break_to_mask_button">マスク化</button>
            <button id="release_targetting_button">選択解除(Ctrl+d)</button>
        </p>
        <p>
            <button id="turn_mask_button">マスク反転</button>
            <button id="delete_mask_button">マスク消去</button>
        </p>
    </div>
    <div id="mapchipsblock">
        <p>
            パレット読み込み<input type="file" accept="image/*" id="mapchip_filepath">
        </p>
        <div id="blank_frame">
        </div>
        <input type="color" id="palette_color" value="#000000">
        <label for="palette_color">パレット色変更</label>
    </div>

    <canvas id="mapchip_bg" width="1" height="1" hidden></canvas>

<script>/******/ (() => { // webpackBootstrap
/*!***********************!*\
  !*** ./built/main.js ***!
  \***********************/
var WindowsIndexColorBitmap;
(function (WindowsIndexColorBitmap) {
    const bmp_file_header_size = 14;
    const bmp_info_header_size = 40;
    const palette_size = 4 * 256;
    const pixels_offset = bmp_file_header_size + bmp_info_header_size + palette_size;
    const Store16LE = function (bytes, offset, value) {
        bytes[offset + 0] = value & 0x00ff;
        bytes[offset + 1] = (value >> 8) & 0x00ff;
    };
    const Store32LE = function (bytes, offset, value) {
        bytes[offset + 0] = value & 0x000000ff;
        bytes[offset + 1] = (value >> 8) & 0x000000ff;
        bytes[offset + 2] = (value >> 16) & 0x000000ff;
        bytes[offset + 3] = (value >> 24) & 0x000000ff;
    };
    const Load16LE = function (bytes, offset) {
        return (bytes[offset + 0] & 0x00ff) | ((bytes[offset + 1] << 8) & 0xff00);
    };
    const Load32LE = function (bytes, offset) {
        return (bytes[offset + 0] & 0x000000ff)
            | ((bytes[offset + 1] << 8) & 0x0000ff00)
            | ((bytes[offset + 2] << 16) & 0x00ff0000)
            | ((bytes[offset + 3] << 14) & 0xff000000);
    };
    const RgbStringToRgbValues = function (rgb_string) {
        const [r_string, g_string, b_string] = rgb_string.split('(')[1].split(')')[0].split(',');
        return [Number(r_string), Number(g_string), Number(b_string)];
    };
    function Serialize(color_palette, pixels, width, height) {
        const bmp_width = Math.ceil(width / 4) * 4;
        const pixels_size = bmp_width * height;
        const binary_size = bmp_file_header_size + bmp_info_header_size + palette_size + pixels_size;
        const buffer = new ArrayBuffer(binary_size);
        const bytes = new Uint8Array(buffer);
        bytes[0] = 0x42;
        bytes[1] = 0x4d;
        /* Bitmap File Header */
        Store32LE(bytes, 2, binary_size);
        Store16LE(bytes, 6, 0);
        Store16LE(bytes, 8, 0);
        Store32LE(bytes, 10, pixels_offset);
        /* Bitmap Info Header */
        Store32LE(bytes, 14, 40);
        Store32LE(bytes, 18, width);
        Store32LE(bytes, 22, height);
        Store16LE(bytes, 26, 1);
        Store16LE(bytes, 28, 8);
        Store32LE(bytes, 30, 0);
        Store32LE(bytes, 34, pixels_size);
        Store32LE(bytes, 38, 0);
        Store32LE(bytes, 42, 0);
        Store32LE(bytes, 46, 256);
        Store32LE(bytes, 50, 256);
        /* Color palette */
        for (let i = 0; i < 256; i++) {
            const [r, g, b] = RgbStringToRgbValues(color_palette[i]);
            bytes[54 + 4 * i + 0] = b;
            bytes[54 + 4 * i + 1] = g;
            bytes[54 + 4 * i + 2] = r;
            bytes[54 + 4 * i + 3] = 0;
        }
        /* pixels */
        /* ラスタ座標系から数学座標系に入れ替えて出力する */
        for (let h = 0; h < height; h++) {
            for (let w = 0; w < width; w++) {
                let offset = pixels_offset + bmp_width * (height - h - 1) + w;
                bytes[offset] = pixels[h][w];
            }
        }
        return bytes;
    }
    WindowsIndexColorBitmap.Serialize = Serialize;
    function Deserialize(buffer) {
        const bytes = new Uint8Array(buffer);
        console.log(bytes[0]);
        console.log(bytes[1]);
        if (bytes[0] != 0x42) {
            return null;
        }
        if (bytes[1] != 0x4d) {
            return null;
        }
        if (Load32LE(bytes, 10) != pixels_offset) {
            return null;
        }
        if (Load16LE(bytes, 26) != 1) {
            return null;
        }
        if (Load16LE(bytes, 28) != 8) {
            return null;
        }
        const width = Load32LE(bytes, 18);
        const height = Load32LE(bytes, 22);
        const bmp_width = Math.ceil(width / 4) * 4;
        const pixels_size = bmp_width * height;
        if (Load32LE(bytes, 34) != pixels_size) {
            return null;
        }
        const color_palette = new Array(256);
        for (let i = 0; i < 256; i++) {
            const b = bytes[54 + 4 * i + 0];
            const g = bytes[54 + 4 * i + 1];
            const r = bytes[54 + 4 * i + 2];
            color_palette[i] = `rgb(${r},${g},${b})`;
        }
        /* pixels */
        /* 数学座標系からラスタ座標系に入れ替えて読みこむ */
        const pixels = Misc.Make2dArray(width, height, 0);
        for (let h = 0; h < height; h++) {
            for (let w = 0; w < width; w++) {
                let offset = pixels_offset + bmp_width * (height - h - 1) + w;
                pixels[h][w] = bytes[offset];
            }
        }
        return [color_palette, pixels, width, height];
    }
    WindowsIndexColorBitmap.Deserialize = Deserialize;
})(WindowsIndexColorBitmap || (WindowsIndexColorBitmap = {}));
var Misc;
(function (Misc) {
    function Make2dArray(width, height, initial_value) {
        return JSON.parse(JSON.stringify((new Array(height)).fill((new Array(width)).fill(initial_value))));
    }
    Misc.Make2dArray = Make2dArray;
    function LineTo2d(x0, y0, x1, y1, PixelOnLineCallback) {
        const dx = (x0 < x1) ? x1 - x0 : x0 - x1;
        const dy = (y0 < y1) ? y1 - y0 : y0 - y1;
        const sx = (x0 < x1) ? 1 : -1;
        const sy = (y0 < y1) ? 1 : -1;
        let e1 = dx - dy;
        for (;;) {
            PixelOnLineCallback(x0, y0);
            if ((x0 == x1) && (y0 == y1)) {
                break;
            }
            const e2 = e1 * 2;
            if (-dy < e2) {
                e1 -= dy;
                x0 += sx;
            }
            if (e2 < dx) {
                e1 += dx;
                y0 += sy;
            }
        }
    }
    Misc.LineTo2d = LineTo2d;
    ;
    function RgbStringToHexColor(rgb_string) {
        const [r_string, g_string, b_string] = rgb_string.split('(')[1].split(')')[0].split(',');
        const r_hex = ('00' + Number(r_string).toString(16)).slice(-2);
        const g_hex = ('00' + Number(g_string).toString(16)).slice(-2);
        const b_hex = ('00' + Number(b_string).toString(16)).slice(-2);
        return `#${r_hex}${g_hex}${b_hex}`;
    }
    Misc.RgbStringToHexColor = RgbStringToHexColor;
    function ExtractBaseName(filepath) {
        const path_delimiter = /\\/g;
        const path_tokens = filepath.slice(0).replace(path_delimiter, '/').split('/');
        const filename = (2 <= path_tokens.length) ? path_tokens[path_tokens.length - 1] : path_tokens[0];
        const name_tokens = filename.split('.');
        const basename = (2 <= name_tokens.length) ? name_tokens.splice(0, name_tokens.length - 1).join('.') : name_tokens[0];
        return basename;
    }
    Misc.ExtractBaseName = ExtractBaseName;
    function MakeWebSafeColorList() {
        const gray_colors = Array(0); /* 利便性のためにグレースケールだけ別で並べる */
        const other_colors = Array(0);
        const blank_colors = Array(256 - (6 * 6 * 6)).fill('#000000');
        const c = ['00', '33', '66', '99', 'cc', 'ff'];
        let i = 0;
        for (let b = 0; b < 6; b++) {
            for (let g = 0; g < 6; g++) {
                for (let r = 0; r < 6; r++) {
                    const color = `#${c[r]}${c[g]}${c[b]}`;
                    if (r == g && r == b) {
                        gray_colors.push(color);
                    }
                    else {
                        other_colors.push(color);
                    }
                }
            }
        }
        return gray_colors.concat(other_colors).concat(blank_colors);
    }
    Misc.MakeWebSafeColorList = MakeWebSafeColorList;
})(Misc || (Misc = {}));
/// <reference path="./windows_bitmap.ts" />
/// <reference path="./misc.ts" />
class RgbColor {
    constructor(r = 0, g = 0, b = 0) {
        this.r = r;
        this.g = g;
        this.b = b;
    }
    ToHexColor() {
        const r_hex = ('00' + this.r.toString(16)).slice(-2);
        const g_hex = ('00' + this.g.toString(16)).slice(-2);
        const b_hex = ('00' + this.b.toString(16)).slice(-2);
        return `#${r_hex}${g_hex}${b_hex}`;
    }
    ToRgbString() {
        return `rgb(${this.r},${this.g},${this.b})`;
    }
    SetHexColor(hex_color) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex_color);
        if (result) {
            this.r = parseInt(result[1], 16);
            this.g = parseInt(result[2], 16);
            this.b = parseInt(result[3], 16);
        }
        return !!(result);
    }
    SetRgbString(rgb_string) {
        const result = /^rgb\s*\(\s*([\d]+)\s*,\s*([\d]+)\s*,\s*([\d]+)\s*\)/i.exec(rgb_string);
        if (result) {
            this.r = Number(result[1]);
            this.g = Number(result[2]);
            this.b = Number(result[3]);
        }
        return !!(result);
    }
    SetColorString(color_string) {
        return this.SetHexColor(color_string) ? true : this.SetRgbString(color_string);
    }
}
class PixelPoint {
    constructor(w, h) {
        this.w = w;
        this.h = h;
    }
    ToIndex(width) {
        return width * this.h + this.w;
    }
    static IndexToPixelPoint(index, width) {
        const w = Math.floor(index % width);
        const h = Math.floor(index / width);
        return new PixelPoint(w, h);
    }
}
const view_font_size = 8;
const max_edit_width = 512;
const max_edit_height = 512;
const default_edit_width = 32;
const default_edit_height = 32;
const default_edit_scale = 8;
class EditLogger {
    constructor() {
        this.undo_stack_ = new Array(0);
        this.redo_stack_ = new Array(0);
    }
    IsUndoLogEmpty() {
        return (this.undo_stack_.length == 0) ? true : false;
    }
    IsRedoLogEmpty() {
        return (this.redo_stack_.length == 0) ? true : false;
    }
    PushUndoLog(log_data) {
        this.undo_stack_.push(log_data);
    }
    PushRedoLog(log_data) {
        this.redo_stack_.push(log_data);
    }
    PopUndoLog() {
        return this.undo_stack_.pop();
    }
    PopRedoLog() {
        return this.redo_stack_.pop();
    }
    ClearRedoLog() {
        this.redo_stack_.splice(0);
    }
}
class IndexColorBitmap {
    constructor(width, height, color_palette, pixels) {
        this.width = width;
        this.height = height;
        this.color_palette = color_palette;
        this.pixels = pixels;
    }
    ;
}
class Data {
    constructor(default_width, default_height, max_width, max_height) {
        this.edit_width_ = default_width;
        this.edit_height_ = default_height;
        this.pixels_ = Misc.Make2dArray(max_width, max_height, 0);
        this.pixels_written_set_ = new Set();
        this.pixels_mask_ = Misc.Make2dArray(max_width, max_height, false);
        this.selected_color_index_ = 0;
        this.color_palette_ = new Array(256);
        for (let i = 0; i < 256; i++) {
            this.color_palette_[i] = new RgbColor();
        }
        this.logger_ = new EditLogger();
    }
    get edit_scale() {
        return this.edit_scale_;
    }
    set edit_scale(new_scale) {
        this.edit_scale_ = new_scale;
        this.is_edit_view_touched_ = true;
    }
    get edit_width() {
        return this.edit_width_;
    }
    set edit_width(new_width) {
        this.edit_width_ = new_width;
        this.is_edit_view_touched_ = true;
    }
    get edit_height() {
        return this.edit_height_;
    }
    set edit_height(new_height) {
        this.edit_height_ = new_height;
        this.is_edit_view_touched_ = true;
    }
    get selected_color_index() {
        return this.selected_color_index_;
    }
    set selected_color_index(new_index) {
        this.selected_color_index_ = new_index;
    }
    get is_edit_view_touched() {
        return this.is_edit_view_touched_;
    }
    TouchEditView() {
        this.is_edit_view_touched_ = true;
    }
    ClearEditViewTouchedFlag() {
        this.is_edit_view_touched_ = false;
    }
    SetMaskFlagsByRectangle(left, top, right, bottom, flag) {
        for (let h = top; h < bottom; h++) {
            for (let w = left; w < right; w++) {
                this.pixels_mask_[h][w] = flag;
            }
        }
    }
    TurnMask() {
        for (let h = 0; h < this.edit_height_; h++) {
            for (let w = 0; w < this.edit_width_; w++) {
                this.pixels_mask_[h][w] = !this.pixels_mask_[h][w];
            }
        }
    }
    IsMasked(point) {
        return this.pixels_mask_[point.h][point.w];
    }
    WriteMap(point, color_index) {
        if (this.pixels_mask_[point.h][point.w]) {
            return;
        }
        this.pixels_[point.h][point.w] = color_index;
        this.pixels_written_set_.add(point.ToIndex(this.edit_width_));
    }
    TouchPixel(point) {
        this.pixels_written_set_.add(point.ToIndex(this.edit_width_));
    }
    GetWrittenColorIndex(point) {
        return this.pixels_[point.h][point.w];
    }
    GetWrittenPixelSet() {
        return this.pixels_written_set_;
    }
    SetRgbColorToPalette(index, color) {
        this.color_palette_[index].r = color.r;
        this.color_palette_[index].g = color.g;
        this.color_palette_[index].b = color.b;
    }
    GetRgbColorFromPalette(index) {
        return this.color_palette_[index];
    }
    MakeRawSaveData() {
        const edit_w_count = this.edit_width_;
        const edit_h_count = this.edit_height_;
        const save_tiles = new Array(edit_h_count);
        for (var h = 0; h < edit_h_count; h++) {
            save_tiles[h] = this.pixels_[h].slice(0, edit_w_count);
        }
        const color_palette = new Array(256);
        for (var i = 0; i < 256; i++) {
            color_palette[i] = this.color_palette_[i].ToRgbString();
        }
        return new IndexColorBitmap(edit_w_count, edit_h_count, color_palette, save_tiles);
    }
    ApplyRawData(raw_data) {
        this.edit_width_ = raw_data.width;
        this.edit_height_ = raw_data.height;
        for (let h = 0; h < raw_data.height; h++) {
            for (let w = 0; w < raw_data.width; w++) {
                this.pixels_[h][w] = raw_data.pixels[h][w];
            }
        }
        for (let i = 0; i < 256; i++) {
            data.GetRgbColorFromPalette(i).SetColorString(raw_data.color_palette[i]);
        }
        this.TouchEditView();
    }
    PushUndoLog() {
        const current_data = data.MakeRawSaveData();
        this.logger_.PushUndoLog(current_data);
        this.logger_.ClearRedoLog();
    }
    Undo() {
        if (this.logger_.IsUndoLogEmpty()) {
            return;
        }
        const current_data = data.MakeRawSaveData();
        this.logger_.PushRedoLog(current_data);
        const undo_data = this.logger_.PopUndoLog();
        this.ApplyRawData(undo_data);
    }
    Redo() {
        if (this.logger_.IsRedoLogEmpty()) {
            return;
        }
        const current_data = data.MakeRawSaveData();
        this.logger_.PushUndoLog(current_data);
        const redo_data = this.logger_.PopRedoLog();
        this.ApplyRawData(redo_data);
    }
}
const ApplyView = function () {
    for (let i = 0; i < 256; i++) {
        dom.color_palette[i].style.backgroundColor = data.GetRgbColorFromPalette(i).ToRgbString();
    }
    dom.editwidth.value = data.edit_width.toString();
    dom.editheight.value = data.edit_height.toString();
    return;
};
class RectangleTargetPixels {
    constructor(point1, point2) {
        this.Update(point1, point2);
    }
    Update(point1, point2) {
        this.left = (point1.w < point2.w) ? point1.w : point2.w;
        this.right = (point1.w < point2.w) ? point2.w : point1.w;
        this.top = (point1.h < point2.h) ? point1.h : point2.h;
        this.bottom = (point1.h < point2.h) ? point2.h : point1.h;
    }
    In(point) {
        const is_contain = ((this.left <= point.w) && (point.w <= this.right) &&
            (this.top <= point.h) && (point.h <= this.bottom));
        return is_contain;
    }
    BrakedownToPixelMask() {
        data.SetMaskFlagsByRectangle(this.left, this.top, this.right, this.bottom, true);
    }
    Draw(canvas_context, view_scale, frame_count) {
        const dot_span = 5;
        const edit_context = dom.edit_canvas.getContext("2d");
        edit_context.scale(1, 1);
        canvas_context = edit_context;
        let z = this.left + (frame_count % dot_span);
        canvas_context.fillStyle = '#ffffff';
        for (; z <= this.right; z += dot_span) {
            canvas_context.fillRect(z, this.top, 1, 1);
            data.TouchPixel(new PixelPoint(z, this.top));
        }
        z = z - this.right + this.top;
        for (; z <= this.bottom; z += dot_span) {
            canvas_context.fillRect(this.right, z, 1, 1);
            data.TouchPixel(new PixelPoint(this.right, z));
        }
        z = this.right - (z - this.bottom);
        for (; this.left <= z; z -= dot_span) {
            canvas_context.fillRect(z, this.bottom, 1, 1);
            data.TouchPixel(new PixelPoint(z, this.bottom));
        }
        z = this.bottom - (this.left - z);
        for (; this.top <= z; z -= dot_span) {
            canvas_context.fillRect(this.left, z, 1, 1);
            data.TouchPixel(new PixelPoint(this.left, z));
        }
    }
    VerticalTurn() {
        const half_h = Number(Math.floor((this.bottom - this.top + 1) / 2));
        const max_h = this.top + half_h;
        for (let h1 = this.top, h2 = this.bottom; h1 < max_h; h1++, h2--) {
            for (let w = this.left; w <= this.right; w++) {
                const p1 = new PixelPoint(w, h1);
                const p2 = new PixelPoint(w, h2);
                const c1 = data.GetWrittenColorIndex(p1);
                const c2 = data.GetWrittenColorIndex(p2);
                data.WriteMap(p1, c2);
                data.WriteMap(p2, c1);
            }
        }
    }
    HorizontalTurn() {
        const half_w = Number(Math.floor((this.right - this.left + 1) / 2));
        const max_w = this.left + half_w;
        for (let w1 = this.left, w2 = this.right; w1 < max_w; w1++, w2--) {
            for (let h = this.top; h <= this.bottom; h++) {
                const p1 = new PixelPoint(w1, h);
                const p2 = new PixelPoint(w2, h);
                const c1 = data.GetWrittenColorIndex(p1);
                const c2 = data.GetWrittenColorIndex(p2);
                data.WriteMap(p1, c2);
                data.WriteMap(p2, c1);
            }
        }
    }
}
class Tool {
    LeftButtonDown(event) { }
    ;
    LeftButtonUp(event) { }
    ;
    RightButtonDown(event) { }
    ;
    RightButtonUp(event) { }
    ;
    MouseMove(event) { }
    ;
    MouseOut(event) { }
    ;
    static GetTilePoint(event, block_size) {
        const rect = event.target.getBoundingClientRect();
        const w = Math.floor((event.clientX - rect.left) / block_size);
        const h = Math.floor((event.clientY - rect.top) / block_size);
        return new PixelPoint(w, h);
    }
    ;
}
class PenTool extends Tool {
    constructor() {
        super(...arguments);
        this.WritePixel = function (x, y) {
            data.WriteMap(new PixelPoint(x, y), data.selected_color_index);
        };
    }
    LeftButtonDown(event) {
        data.PushUndoLog();
        const point = Tool.GetTilePoint(event, data.edit_scale);
        data.WriteMap(point, data.selected_color_index);
        this.last_point = point;
        return;
    }
    ;
    RightButtonDown(event) {
        const point = Tool.GetTilePoint(event, data.edit_scale);
        data.selected_color_index = data.GetWrittenColorIndex(point);
        return;
    }
    ;
    MouseMove(event) {
        if (event.buttons === 1) {
            const point = Tool.GetTilePoint(event, data.edit_scale);
            if (this.last_point != null) {
                Misc.LineTo2d(this.last_point.w, this.last_point.h, point.w, point.h, this.WritePixel);
            }
            this.last_point = point;
        }
        return;
    }
    ;
    MouseOut(event) {
        if (event.buttons === 1) {
            const point = Tool.GetTilePoint(event, data.edit_scale);
            if (this.last_point != null) {
                Misc.LineTo2d(this.last_point.w, this.last_point.h, point.w, point.h, this.WritePixel);
            }
        }
        this.last_point = null;
    }
    ;
}
const ExtractRegionPixelSet = function (start_point) {
    const min_w = 0;
    const min_h = 0;
    const max_w = data.edit_width;
    const max_h = data.edit_height;
    const region_pixels = new Set();
    const next_pixel_queue = new Array();
    const target_color_index = data.GetWrittenColorIndex(start_point);
    region_pixels.add(start_point.ToIndex(max_w));
    next_pixel_queue.push(start_point);
    const AddPixelToRegion = function (new_point) {
        if (data.GetWrittenColorIndex(new_point) != target_color_index) {
            return;
        }
        if (region_pixels.has(new_point.ToIndex(max_w))) {
            return;
        }
        next_pixel_queue.push(new_point);
        region_pixels.add(new_point.ToIndex(max_w));
        return;
    };
    for (;;) {
        if (next_pixel_queue.length == 0) {
            break;
        }
        let pixel = next_pixel_queue.shift();
        if (min_h < pixel.h) {
            AddPixelToRegion(new PixelPoint(pixel.w + 0, pixel.h - 1));
        }
        if (min_w < pixel.w) {
            AddPixelToRegion(new PixelPoint(pixel.w - 1, pixel.h + 0));
        }
        if (pixel.w < max_w - 1) {
            AddPixelToRegion(new PixelPoint(pixel.w + 1, pixel.h + 0));
        }
        if (pixel.h < max_h - 1) {
            AddPixelToRegion(new PixelPoint(pixel.w + 0, pixel.h + 1));
        }
    }
    return region_pixels;
};
class PaintTool extends Tool {
    LeftButtonDown(event) {
        data.PushUndoLog();
        const selected_pixel = Tool.GetTilePoint(event, data.edit_scale);
        const new_color_index = data.selected_color_index;
        const region_pixel_set = ExtractRegionPixelSet(selected_pixel);
        const max_w = data.edit_width;
        region_pixel_set.forEach((pixel_index) => {
            data.WriteMap(PixelPoint.IndexToPixelPoint(pixel_index, max_w), new_color_index);
        });
    }
    ;
    RightButtonDown(event) {
        const point = Tool.GetTilePoint(event, data.edit_scale);
        data.selected_color_index = data.GetWrittenColorIndex(point);
    }
    ;
}
class RectangleSelectTool extends Tool {
    constructor() {
        super();
        this.start_point = null;
    }
    LeftButtonDown(event) {
        this.start_point = Tool.GetTilePoint(event, data.edit_scale);
        if (target_pixels != null) {
            target_pixels.Update(this.start_point, this.start_point);
        }
        else {
            target_pixels = new RectangleTargetPixels(this.start_point, this.start_point);
        }
    }
    ;
    MouseMove(event) {
        if (event.buttons === 1) {
            const point = Tool.GetTilePoint(event, data.edit_scale);
            if (target_pixels != null && this.start_point != null) {
                target_pixels.Update(this.start_point, point);
            }
            else {
                this.start_point = point;
                target_pixels.Update(this.start_point, this.start_point);
            }
        }
        return;
    }
    ;
}
const data = new Data(default_edit_width, default_edit_height, max_edit_width, max_edit_height);
const pen_tool = new PenTool();
const paint_tool = new PaintTool();
const rentangle_select_tool = new RectangleSelectTool();
let tool = pen_tool;
let target_pixels = null;
function GetHtmlElement(element_id) {
    return document.getElementById(element_id);
}
const MouseDownCallback = function (event) {
    if (event.button === 0) {
        tool.LeftButtonDown(event);
    }
    else if (event.button === 2) {
        tool.RightButtonDown(event);
    }
};
const MouseUpCallback = function (event) {
    if (event.button === 0) {
        tool.LeftButtonUp(event);
    }
    else if (event.button === 2) {
        tool.RightButtonUp(event);
    }
};
const MouseMoveCallback = function (event) {
    tool.MouseMove(event);
};
const MouseOutCallback = function (event) {
    tool.MouseOut(event);
};
const FitDivWidth = function (modify_div_id, referencet_div_id) {
    const new_width = GetHtmlElement(referencet_div_id).clientWidth;
    GetHtmlElement(modify_div_id).style.width = `${new_width}px`;
};
const FitDivHeight = function (modify_div_id, referencet_div_id) {
    const new_height = GetHtmlElement(referencet_div_id).clientHeight;
    GetHtmlElement(modify_div_id).style.height = `${new_height}px`;
};
const TryReadEditDataByJson = function (bytes) {
    const read_data = JSON.parse(bytes);
    data.ApplyRawData(read_data);
    ApplyView();
    return true;
};
const LoadEditData = function (bytes) {
    const bmp_data = WindowsIndexColorBitmap.Deserialize(bytes);
    if (bmp_data != null) {
        const [color_palette, pixels, width, height] = bmp_data;
        const raw_data = new IndexColorBitmap(width, height, color_palette, pixels);
        data.ApplyRawData(raw_data);
        ApplyView();
        return true;
    }
    const bs = Array.from(new Uint8Array(bytes), (v) => String.fromCharCode(v)).join("");
    if (TryReadEditDataByJson(bs)) {
        return true;
    }
    return false;
};
function MakeTable(table_id, cols, rows, parent_dom) {
    let tag_text = `<table id="${table_id}">`;
    for (let row_i = 0; row_i < rows; row_i++) {
        tag_text += "<tr>";
        for (let col_i = 0; col_i < cols; col_i++) {
            tag_text += `<td id \="${table_id}#${row_i * cols + col_i}"><canvas width="16" height="16"></canvas></td>`;
        }
        tag_text += "<td>";
    }
    tag_text += "</table>";
    parent_dom.innerHTML += tag_text;
    const num_cells = cols * rows;
    const cells = Array(num_cells);
    for (let i = 0; i < 256; i++) {
        cells[i] = GetHtmlElement(`${table_id}#${i}`);
    }
    return cells;
}
class Dom {
    Initialize() {
        this.edit_canvas = GetHtmlElement('edit');
        this.view_canvas = GetHtmlElement('view');
        this.blank_frame = GetHtmlElement('blank_frame');
        this.edit_frame = GetHtmlElement('editframe');
        this.palette_color = GetHtmlElement('palette_color');
        this.editwidth = GetHtmlElement('editwidth');
        this.editheight = GetHtmlElement('editheight');
        this.edit_scale = GetHtmlElement('edit_scale');
        this.view_scale = GetHtmlElement('view_scale');
        this.edit_filepath = GetHtmlElement('edit_filepath');
        this.view_index = GetHtmlElement('view_index');
        this.view_grid = GetHtmlElement('view_grid');
        this.dom_pen_tool = GetHtmlElement('pen_tool');
        this.dom_paint_tool = GetHtmlElement('paint_tool');
        this.dom_rectangle_select_tool = GetHtmlElement('rectangle_select_tool');
        this.grid_color = GetHtmlElement('grid_color');
        this.canvas_bg_color = GetHtmlElement('canvas_bg_color');
        this.save_picture_button = GetHtmlElement('download_edit_data');
        this.edit_data_name = GetHtmlElement('edit_data_name');
        this.color_palette = new Array(256);
        this.undo_button = GetHtmlElement('undo_button');
        this.redo_button = GetHtmlElement('redo_button');
        this.h_turn_button = GetHtmlElement('h_turn_button');
        this.v_turn_button = GetHtmlElement('v_turn_button');
        this.break_to_mask_button = GetHtmlElement('break_to_mask_button');
        this.release_targetting_button = GetHtmlElement('release_targetting_button');
        this.turn_mask_button = GetHtmlElement('turn_mask_button');
        this.delete_mask_button = GetHtmlElement('delete_mask_button');
    }
}
const dom = new Dom();
const DrawLine = function (canvas_context, start_x, start_y, end_x, end_y) {
    canvas_context.moveTo(start_x, start_y);
    canvas_context.lineTo(end_x, end_y);
};
const PartiallyDrawGrid = function (canvas_context, w_grid_set, h_grid_set, width_count, height_count, scale, grid_size, grid_color) {
    canvas_context.beginPath();
    const line_height = height_count * grid_size;
    const line_width = width_count * grid_size;
    const adjust_e = -(1 / scale) / 2;
    for (let w of w_grid_set) {
        const x = (w + 1) * grid_size + adjust_e;
        DrawLine(canvas_context, x, -0.5, x, line_height + 0.5);
    }
    for (let h of h_grid_set) {
        const y = (h + 1) * grid_size + adjust_e;
        DrawLine(canvas_context, -0.5, y, line_width + 0.5, y);
    }
    canvas_context.lineWidth = 1 / scale;
    canvas_context.strokeStyle = grid_color;
    canvas_context.stroke();
};
const DrawGrid = function (canvas_context, width_count, height_count, scale, grid_size, grid_color) {
    const all_w_grid_set = new Set();
    const all_h_grid_set = new Set();
    for (var w = 0; w < width_count; w++) {
        all_w_grid_set.add(w);
    }
    for (var h = 0; h < height_count; h++) {
        all_h_grid_set.add(h);
    }
    PartiallyDrawGrid(canvas_context, all_w_grid_set, all_h_grid_set, width_count, height_count, scale, grid_size, grid_color);
};
const PartiallyDrawMapchipIndex = function (edit_context, target_maptile_set, view_scale, color) {
    const font_size = view_font_size;
    edit_context.save();
    edit_context.textAlign = "center";
    edit_context.textBaseline = "middle";
    edit_context.font = `${font_size}px gothic`;
    edit_context.fillStyle = color;
    edit_context.scale(1 / view_scale, 1 / view_scale);
    const y_offset = font_size / 2;
    const width = data.edit_width;
    target_maptile_set.forEach((pixel_index) => {
        const point = PixelPoint.IndexToPixelPoint(pixel_index, width);
        const dst_x = point.w * view_scale;
        const dst_y = point.h * view_scale;
        const ci = data.GetWrittenColorIndex(point);
        const x_offset = view_scale - String(ci).length * (font_size / 2 - 1) - 1;
        edit_context.fillText(ci.toString(), dst_x + x_offset, dst_y + y_offset);
    });
    edit_context.restore();
};
const DrawMapchipIndex = function (edit_context, edit_w_count, edit_h_count, view_scale, color) {
    const target_maptile_set = new Set();
    for (var h = 0; h < edit_h_count; h++) {
        for (var w = 0; w < edit_w_count; w++) {
            target_maptile_set.add((new PixelPoint(w, h)).ToIndex(edit_w_count));
        }
    }
    PartiallyDrawMapchipIndex(edit_context, target_maptile_set, view_scale, color);
};
const UpdateMaskedPixels = function (frame_count) {
    const edit_context = dom.edit_canvas.getContext("2d");
    edit_context.scale(1, 1);
    const max_w = data.edit_width;
    const max_h = data.edit_height;
    frame_count = frame_count % (data.edit_height + data.edit_width);
    for (let w = 0, h = frame_count - 1; w < frame_count; w++, h--) {
        if ((max_w <= w) || (max_h <= h)) {
            continue;
        }
        const point = new PixelPoint(w, h);
        if (!data.IsMasked(point)) {
            continue;
        }
        edit_context.fillStyle = '#ffffff';
        edit_context.fillRect(w, h, 1, 1);
        data.TouchPixel(point);
    }
};
const UpdateEditViewUpdateTiles = function (edit_w_count, edit_h_count, view_scale) {
    const written_pixel_set = data.GetWrittenPixelSet();
    const edit_context = dom.edit_canvas.getContext("2d");
    edit_context.scale(1, 1);
    edit_context.imageSmoothingEnabled = false;
    const view_context = dom.view_canvas.getContext('2d');
    view_context.scale(1, 1);
    view_context.imageSmoothingEnabled = false;
    const update_w_grid_set = new Set();
    const update_h_grid_set = new Set();
    written_pixel_set.forEach((pixel_index) => {
        const point = PixelPoint.IndexToPixelPoint(pixel_index, edit_w_count);
        update_w_grid_set.add(point.w);
        update_h_grid_set.add(point.h);
        const dst_x = point.w;
        const dst_y = point.h;
        const mi = data.GetWrittenColorIndex(point);
        const color = data.GetRgbColorFromPalette(mi).ToHexColor();
        edit_context.fillStyle = color;
        edit_context.fillRect(dst_x, dst_y, 1, 1);
        view_context.fillStyle = color;
        view_context.fillRect(dst_x, dst_y, 1, 1);
    });
    const grid_color = dom.grid_color.value;
    if (dom.view_grid.checked) {
        PartiallyDrawGrid(edit_context, update_w_grid_set, update_h_grid_set, edit_w_count, edit_h_count, view_scale, 1, grid_color);
    }
    if (dom.view_index.checked) {
        PartiallyDrawMapchipIndex(edit_context, written_pixel_set, view_scale, grid_color);
    }
    written_pixel_set.clear();
};
const UpdatePreview = function (edit_w_count, edit_h_count, view_scale) {
    const view_context = dom.view_canvas.getContext('2d');
    dom.view_canvas.width = edit_w_count * view_scale;
    dom.view_canvas.height = edit_h_count * view_scale;
    view_context.imageSmoothingEnabled = false;
    view_context.scale(view_scale, view_scale);
    for (var h = 0; h < edit_h_count; h++) {
        for (var w = 0; w < edit_w_count; w++) {
            const dst_x = w;
            const dst_y = h;
            const mi = data.GetWrittenColorIndex(new PixelPoint(w, h));
            view_context.fillStyle = data.GetRgbColorFromPalette(mi).ToHexColor();
            ;
            view_context.fillRect(dst_x, dst_y, 1, 1);
        }
    }
};
const UpdateEditView = function (edit_w_count, edit_h_count, view_scale) {
    const edit_context = dom.edit_canvas.getContext("2d");
    dom.edit_canvas.width = edit_w_count * view_scale;
    dom.edit_canvas.height = edit_h_count * view_scale;
    edit_context.imageSmoothingEnabled = false;
    edit_context.scale(view_scale, view_scale);
    for (var h = 0; h < edit_h_count; h++) {
        for (var w = 0; w < edit_w_count; w++) {
            const dst_x = w;
            const dst_y = h;
            const mi = data.GetWrittenColorIndex(new PixelPoint(w, h));
            edit_context.fillStyle = data.GetRgbColorFromPalette(mi).ToHexColor();
            edit_context.fillRect(dst_x, dst_y, 1, 1);
        }
    }
    const grid_color = dom.grid_color.value;
    if (dom.view_index.checked) {
        DrawMapchipIndex(edit_context, edit_w_count, edit_h_count, view_scale, grid_color);
    }
    if (dom.view_grid.checked) {
        DrawGrid(edit_context, edit_w_count, edit_h_count, view_scale, 1, grid_color);
    }
};
var frame_count = 0;
const UpdateView = function () {
    if (data.is_edit_view_touched) {
        UpdateEditView(data.edit_width, data.edit_height, data.edit_scale);
        UpdatePreview(data.edit_width, data.edit_height, dom.view_scale.value);
        data.ClearEditViewTouchedFlag();
    }
    else {
        UpdateEditViewUpdateTiles(data.edit_width, data.edit_height, data.edit_scale);
    }
    if (target_pixels != null) {
        target_pixels.Draw(dom.edit_canvas.getContext("2d"), data.edit_scale, frame_count);
    }
    UpdateMaskedPixels(frame_count);
    dom.edit_frame.style.backgroundColor = dom.canvas_bg_color.value;
    frame_count++;
    window.requestAnimationFrame(UpdateView);
};
function Initialize() {
    dom.Initialize();
    const edit_reader = new FileReader();
    dom.edit_canvas.width = 256;
    dom.edit_canvas.height = 192;
    FitDivWidth('editframe', 'editblock');
    FitDivWidth('viewframe', 'viewblock');
    FitDivHeight('viewframe', 'viewblock');
    dom.edit_canvas.addEventListener('mousedown', MouseDownCallback);
    dom.edit_canvas.addEventListener('mouseup', MouseUpCallback);
    dom.edit_canvas.addEventListener('contextmenu', MouseDownCallback);
    dom.edit_canvas.addEventListener('mousemove', MouseMoveCallback);
    dom.edit_canvas.addEventListener('mouseout', MouseOutCallback);
    dom.editwidth.max = max_edit_width.toString();
    dom.editheight.max = max_edit_height.toString();
    dom.editwidth.value = default_edit_width.toString();
    dom.editheight.value = default_edit_height.toString();
    dom.edit_scale.value = default_edit_scale.toString();
    data.edit_width = dom.editwidth.valueAsNumber;
    data.edit_height = dom.editheight.valueAsNumber;
    data.edit_scale = Number(dom.edit_scale.value);
    dom.editwidth.addEventListener('change', (event) => {
        data.edit_width = event.target.valueAsNumber;
    });
    dom.editheight.addEventListener('change', (event) => {
        data.edit_height = event.target.valueAsNumber;
    });
    dom.edit_scale.addEventListener('change', (event) => {
        data.edit_scale = Number(event.target.value);
    });
    dom.edit_filepath.addEventListener('change', (event) => {
        edit_reader.readAsArrayBuffer(event.target.files[0]);
    });
    dom.view_index.addEventListener('change', (event) => {
        data.TouchEditView();
    });
    dom.view_grid.addEventListener('change', (event) => {
        data.TouchEditView();
    });
    dom.grid_color.addEventListener('input', (event) => {
        data.TouchEditView();
    });
    dom.canvas_bg_color.addEventListener('input', (event) => {
        dom.edit_frame.style.backgroundColor = event.target.value;
    });
    dom.dom_pen_tool.addEventListener('change', (event) => {
        tool = pen_tool;
    });
    dom.dom_paint_tool.addEventListener('change', (event) => {
        tool = paint_tool;
    });
    dom.dom_rectangle_select_tool.addEventListener('change', (event) => {
        tool = rentangle_select_tool;
    });
    dom.save_picture_button.addEventListener('click', DownloadEditData);
    edit_reader.addEventListener('load', (event) => {
        LoadEditData(event.target.result);
        const basename = Misc.ExtractBaseName(dom.edit_filepath.value);
        dom.edit_data_name.value = basename;
        data.TouchEditView();
    });
    dom.color_palette = MakeTable('color_palette', 16, 16, dom.blank_frame);
    const hex_color_string_array = Misc.MakeWebSafeColorList();
    for (let i = 0; i < 256; i++) {
        const color_cell = dom.color_palette[i];
        const hex_color = hex_color_string_array[i];
        data.GetRgbColorFromPalette(i).SetHexColor(hex_color);
        color_cell.style.backgroundColor = hex_color;
        color_cell.addEventListener('click', () => {
            data.selected_color_index = i;
            dom.palette_color.value = data.GetRgbColorFromPalette(i).ToHexColor();
        });
    }
    dom.palette_color.addEventListener('input', (event) => {
        const i = data.selected_color_index;
        const rgb_color = data.GetRgbColorFromPalette(i);
        data.GetRgbColorFromPalette(i).SetHexColor(event.target.value);
        dom.color_palette[i].style.backgroundColor = rgb_color.ToRgbString();
        data.TouchEditView();
    });
    dom.undo_button.addEventListener('click', (event) => {
        data.Undo();
        ApplyView();
    });
    dom.redo_button.addEventListener('click', (event) => {
        data.Redo();
        ApplyView();
    });
    dom.v_turn_button.addEventListener('click', (event) => {
        if (target_pixels != null) {
            target_pixels.VerticalTurn();
        }
    });
    dom.h_turn_button.addEventListener('click', (event) => {
        if (target_pixels != null) {
            target_pixels.HorizontalTurn();
        }
    });
    dom.break_to_mask_button.addEventListener('click', (event) => {
        if (target_pixels != null) {
            target_pixels.BrakedownToPixelMask();
        }
    });
    dom.release_targetting_button.addEventListener('click', (event) => {
        target_pixels = null;
    });
    dom.turn_mask_button.addEventListener('click', (event) => {
        data.TurnMask();
    });
    dom.delete_mask_button.addEventListener('click', (event) => {
        data.SetMaskFlagsByRectangle(0, 0, data.edit_width, data.edit_height, false);
    });
    window.addEventListener('keydown', (event) => {
        if (event.ctrlKey) {
            switch (event.key) {
                case 'z':
                    data.Undo();
                    ApplyView();
                    break;
                case 'y':
                    data.Redo();
                    ApplyView();
                    break;
                case 'd':
                    target_pixels = null;
                    break;
            }
        }
    });
    window.requestAnimationFrame(UpdateView);
}
const MakeSaveDataBlobAsWindowsIndexColorBitmap = function () {
    const save_data = data.MakeRawSaveData();
    const bmp_bytes = WindowsIndexColorBitmap.Serialize(save_data.color_palette, save_data.pixels, save_data.width, save_data.height);
    const save_data_blob = new Blob([bmp_bytes]);
    return save_data_blob;
};
const MakeSaveDataBlobAsJson = function () {
    const save_data = data.MakeRawSaveData();
    const save_data_json = JSON.stringify(save_data);
    const save_data_blob = new Blob([save_data_json], {
        type: 'application/json'
    });
    return save_data_blob;
};
const MakeSaveData = function (basename, save_format) {
    switch (save_format) {
        case "WindowsIndexColorBitmap":
            return [`${basename}.bmp`, MakeSaveDataBlobAsWindowsIndexColorBitmap()];
        case "JSON":
        default:
            return [`${basename}.json`, MakeSaveDataBlobAsJson()];
    }
};
function DownloadEditData() {
    const basename = dom.edit_data_name.value;
    const save_format = GetHtmlElement('edit_save_format').value;
    const [savefilename, savedata_blob] = MakeSaveData(basename, save_format);
    const object_url = window.URL.createObjectURL(savedata_blob);
    const user_agent = window.navigator.userAgent.toLowerCase();
    const download_link = GetHtmlElement('download_edit_data');
    download_link.setAttribute('href', object_url);
    download_link.setAttribute('download', savefilename);
}
Initialize();

/******/ })()
;</script></body>

</html>